/// <reference path="./custom.d.ts" />
// tslint:disable
// @ts-nocheck
/**
 * PodcastIndex.org API
 * # Overview The Podcast Index (Podcast Index LLC) is a software developer focused partnership that provides tools and data to anyone who aspires to create new and exciting Podcast experiences without the heavy lifting of indexing, aggregation and data management. # Example Code Users have provided example code for working the API in the following languages:    - [AWS Lambda - python](https://github.com/tbowers/python-podcastindex-org-lambda)   - [C#](https://github.com/ComicStrip/csharp-podcastindex-org-example)   - [Elisp](https://github.com/sabexx/elisp-example)   - [Flutter/Dart](https://github.com/crediblecreative/flutter-dart-podcastindex-org-example)   - [Go](https://github.com/ComicStrip/Go-podcastindex-org-example)   - [Go](https://github.com/kilobit/podcast-index-client)   - [Java](https://github.com/ComicStrip/Java-podcastindex-org-example)   - [Java](https://github.com/stucoates/PodcastIndexJavaClient)   - [Node.js](https://github.com/ComicStrip/node.js-podcastindex-org-example)   - [PHP](https://github.com/Podcastindex-org/example-code)   - [Python](https://github.com/tbowers/python-podcastindex-org-example)   - [Swift](https://github.com/ComicStrip/Swift-podcastindex-org-example)   - ... [More](https://github.com/Podcastindex-org-Examples)  Don't see your desired language, create an example repo and create a [Pull Request](https://github.com/Podcastindex-org/docs-api/pulls) with a link to your example code project! # Libraries User created libraries for working with the API:    - Node.js/npm/yarn       - [podcast-index-api](https://www.npmjs.com/package/podcast-index-api)       - [podcastdx-client](https://www.npmjs.com/package/podcastdx-client)   - Python/pip       - [python-podcastindex](https://pypi.org/project/python-podcastindex/)   - .NET       - [PodcastIndexSharp](https://www.nuget.org/packages/PodcastIndexSharp)  Are we missing a library? Did you create one for a different language? Create a [Pull Request](https://github.com/Podcastindex-org/docs-api/pulls) with a link to the new library! # Postman A collection file for use in the [Postman](https://www.postman.com/) application is available for this API.    1. Download the contents of the [Postman Docs](https://github.com/Podcastindex-org/docs-api/tree/master/Postman%20Docs) folder.   2. Import the `PodcastIndex.postman_collection.json` collection to Postman   3. Import the `PodcastIndexOrgEnvironment.postman_environment.json` to Postman   4. Set the `AuthKey` environment variable   5. Set the `SecretKey` environment variable   6. Hit the Send button (⌘ + return)  # Contributing The source for this API documentation is available at [https://github.com/Podcastindex-org/docs-api](https://github.com/Podcastindex-org/docs-api). Submit an Issue or create a Pull Request. # Authentication Details Sending an API request is easy. We use an Amazon-style request authorization token to secure each request.  Register for a free API key at https://api.podcastindex.org/  These headers parameters are required for each request: `User-Agent`, `X-Auth-Date`, `X-Auth-Key`, `Authorization`  See [Authentication](#auth) for description of parameters.
 *
 * OpenAPI spec version: 1.4.0
 * Contact: info@podcastindex.org
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import portableFetch from "portable-fetch";
import { Configuration } from "./configuration";
import { RESTDataSource } from "apollo-datasource-rest";
// {$CustomDataSourcePlaceholder}

type GenericObject<key, type> = {}

const BASE_PATH = "https://api.podcastindex.org/api/1.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Address of node to receive payment
 * @export
 * @interface AddressDestination
 */
export interface AddressDestination {
}
/**
 * The seemingly best artwork we can find for the feed. Might be the same as `image` in most instances.
 * @export
 * @interface Artwork
 */
export interface Artwork {
}
/**
 * The channel-level author element.  Usually iTunes specific, but could be from another namespace if not present.
 * @export
 * @interface Author
 */
export interface Author {
}
/**
 * An array of categories, where the index is the Category ID and the value is the Category Name.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
 * @export
 * @interface Categories
 */
export interface Categories {
}
/**
 * Link to the JSON file containing the episode chapters
 * @export
 * @interface ChaptersUrl
 */
export interface ChaptersUrl {
}
/**
 * The md5 hash of the following feed items in hex format.    - `title`   - `link`   - `feedLanguage`   - `generator`   - `author`   - `ownerName`   - `ownerEmail` (note: not exposed via the API)  Pseudo-code:        chash = md5(title+link+feedLanguage+generator+author+ownerName+ownerEmail)
 * @export
 * @interface Chash
 */
export interface Chash {
}
/**
 * Hash of the entire feed body
 * @export
 * @interface ContentHash
 */
export interface ContentHash {
}
/**
 * The Content-Type header from the last time we pulled this feed from its url.
 * @export
 * @interface ContentType
 */
export interface ContentType {
}
/**
 * Number of items returned in request
 * @export
 * @interface Count
 */
export interface Count {
}
/**
 * The number of errors we’ve encountered trying to pull a copy of the feed. Errors are things like a 500 or 404 response, a server timeout, bad encoding, etc.
 * @export
 * @interface CrawlErrors
 */
export interface CrawlErrors {
}
/**
 * The time this episode was found in the feed
 * @export
 * @interface DateCrawled
 */
export interface DateCrawled {
}
/**
 * The date and time the episode was published
 * @export
 * @interface DatePublished
 */
export interface DatePublished {
}
/**
 * The date and time the episode was published formatted as a human readable string.  Note: uses the PodcastIndex server local time to do conversion.
 * @export
 * @interface DatePublishedPretty
 */
export interface DatePublishedPretty {
}
/**
 * At some point, we give up trying to process a feed and mark it as dead. This is usually after 1000 errors without a successful pull/parse cycle. Once the feed is marked dead, we only check it once per month.
 * @export
 * @interface Dead
 */
export interface Dead {
}
/**
 * The item-level description of the episode
 * @export
 * @interface DescriptionEpisode
 */
export interface DescriptionEpisode {
}
/**
 * The channel-level description
 * @export
 * @interface DescriptionFeed
 */
export interface DescriptionFeed {
}
/**
 * Description of the response
 * @export
 * @interface DescriptionResponse
 */
export interface DescriptionResponse {
}
/**
 * Destination for \"Value for Value\" payment.
 * @export
 * @interface DestinationV4v
 */
export interface DestinationV4v {
    /**
     *
     * @type {NameDestination}
     * @memberof DestinationV4v
     */
    name: NameDestination;
    /**
     *
     * @type {AddressDestination}
     * @memberof DestinationV4v
     */
    address: AddressDestination;
    /**
     *
     * @type {TypeDestination}
     * @memberof DestinationV4v
     */
    type: TypeDestination;
    /**
     *
     * @type {SplitDestination}
     * @memberof DestinationV4v
     */
    split: SplitDestination;
    /**
     *
     * @type {FeeDestination}
     * @memberof DestinationV4v
     */
    fee: FeeDestination;
}
/**
 * List of destinations where \"Value for Value\" payments should be sent.
 * @export
 * @interface DestinationsV4v
 */
export interface DestinationsV4v extends Array<DestinationV4v> {
}
/**
 * The estimated length of the item specified by the `enclosureUrl` in minutes
 * @export
 * @interface Duration
 */
export interface Duration {
}
/**
 * The length to play the item specified by the `enclosureUrl`
 * @export
 * @interface DurationSoundbite
 */
export interface DurationSoundbite {
}
/**
 * The length of the item specified by the `enclosureUrl` in bytes
 * @export
 * @interface EnclosureLength
 */
export interface EnclosureLength {
}
/**
 * The Content-Type for the item specified by the `enclosureUrl`
 * @export
 * @interface EnclosureType
 */
export interface EnclosureType {
}
/**
 * URL/link to the episode file
 * @export
 * @interface EnclosureUrl
 */
export interface EnclosureUrl {
}
/**
 * Number of episodes for this feed known to the index.
 * @export
 * @interface EpisodeCount
 */
export interface EpisodeCount {
}
/**
 * Episode number
 * @export
 * @interface EpisodeNumber
 */
export interface EpisodeNumber {
}
/**
 * Episode data
 * @export
 * @interface EpisodeObject
 */
export interface EpisodeObject {
    /**
     *
     * @type {IdEpisode}
     * @memberof EpisodeObject
     */
    id: IdEpisode;
    /**
     *
     * @type {TitleFeed}
     * @memberof EpisodeObject
     */
    title: TitleFeed;
    /**
     *
     * @type {LinkFeed}
     * @memberof EpisodeObject
     */
    link: LinkFeed;
    /**
     *
     * @type {DescriptionEpisode}
     * @memberof EpisodeObject
     */
    description: DescriptionEpisode;
    /**
     *
     * @type {Guid}
     * @memberof EpisodeObject
     */
    guid: Guid;
    /**
     *
     * @type {DatePublished}
     * @memberof EpisodeObject
     */
    datePublished: DatePublished;
    /**
     *
     * @type {DatePublishedPretty}
     * @memberof EpisodeObject
     */
    datePublishedPretty: DatePublishedPretty;
    /**
     *
     * @type {DateCrawled}
     * @memberof EpisodeObject
     */
    dateCrawled: DateCrawled;
    /**
     *
     * @type {EnclosureUrl}
     * @memberof EpisodeObject
     */
    enclosureUrl: EnclosureUrl;
    /**
     *
     * @type {EnclosureType}
     * @memberof EpisodeObject
     */
    enclosureType: EnclosureType;
    /**
     *
     * @type {EnclosureLength}
     * @memberof EpisodeObject
     */
    enclosureLength: EnclosureLength;
    /**
     *
     * @type {Duration}
     * @memberof EpisodeObject
     */
    duration: Duration;
    /**
     *
     * @type {Explicit}
     * @memberof EpisodeObject
     */
    explicit: Explicit;
    /**
     *
     * @type {EpisodeNumber}
     * @memberof EpisodeObject
     */
    episode: EpisodeNumber;
    /**
     *
     * @type {EpisodeType}
     * @memberof EpisodeObject
     */
    episodeType: EpisodeType;
    /**
     *
     * @type {Season}
     * @memberof EpisodeObject
     */
    season: Season;
    /**
     *
     * @type {ImageEpisode}
     * @memberof EpisodeObject
     */
    image: ImageEpisode;
    /**
     *
     * @type {ItunesIdFeed}
     * @memberof EpisodeObject
     */
    feedItunesId: ItunesIdFeed;
    /**
     *
     * @type {ImageFeed}
     * @memberof EpisodeObject
     */
    feedImage: ImageFeed;
    /**
     *
     * @type {IdFeed}
     * @memberof EpisodeObject
     */
    feedId: IdFeed;
    /**
     *
     * @type {TitleFeed}
     * @memberof EpisodeObject
     */
    feedTitle: TitleFeed;
    /**
     *
     * @type {Language}
     * @memberof EpisodeObject
     */
    feedLanguage: Language;
    /**
     *
     * @type {ChaptersUrl}
     * @memberof EpisodeObject
     */
    chaptersUrl: ChaptersUrl;
    /**
     *
     * @type {TranscriptUrl}
     * @memberof EpisodeObject
     */
    transcriptUrl: TranscriptUrl;
    /**
     *
     * @type {Soundbite}
     * @memberof EpisodeObject
     */
    soundbite: Soundbite;
    /**
     *
     * @type {Soundbites}
     * @memberof EpisodeObject
     */
    soundbites: Soundbites;
}
/**
 * The type of episode
 * @export
 * @enum {string}
 */
export const EpisodeType = {
    Full:'full',
    Trailer:'trailer',
    Bonus:'bonus'
} as const

export type EpisodeType = typeof EpisodeType[keyof typeof EpisodeType]
/**
 * List of episodes matching request
 * @export
 * @interface EpisodesRandomArray
 */
export interface EpisodesRandomArray extends Array<ItemPodcastRandom> {
}
/**
 * Indicates if feed already exists in the index
 * @export
 * @enum {string}
 */
export const Existed = {
    True:'true',
    False:'false'
} as const

export type Existed = typeof Existed[keyof typeof Existed]
/**
 * Is episode marked as explicit    - 0: not marked explicit   - 1: marked explicit
 * @export
 * @enum {string}
 */
export const Explicit = {
    NUMBER_0:0,
    NUMBER_1:1
} as const

export type Explicit = typeof Explicit[keyof typeof Explicit]
/**
 * Indicates if destination is included due to a fee being charged
 * @export
 * @interface FeeDestination
 */
export interface FeeDestination {
}
/**
 *
 * @export
 * @interface FeedBytag
 */
export interface FeedBytag {
    /**
     *
     * @type {IdFeed}
     * @memberof FeedBytag
     */
    id: IdFeed;
    /**
     *
     * @type {TitleFeed}
     * @memberof FeedBytag
     */
    title: TitleFeed;
    /**
     *
     * @type {UrlFeed}
     * @memberof FeedBytag
     */
    url: UrlFeed;
    /**
     *
     * @type {OriginalUrl}
     * @memberof FeedBytag
     */
    originalUrl: OriginalUrl;
    /**
     *
     * @type {LinkFeed}
     * @memberof FeedBytag
     */
    link: LinkFeed;
    /**
     *
     * @type {DescriptionFeed}
     * @memberof FeedBytag
     */
    description: DescriptionFeed;
    /**
     *
     * @type {Author}
     * @memberof FeedBytag
     */
    author: Author;
    /**
     *
     * @type {OwnerName}
     * @memberof FeedBytag
     */
    ownerName: OwnerName;
    /**
     *
     * @type {ImageFeed}
     * @memberof FeedBytag
     */
    image: ImageFeed;
    /**
     *
     * @type {Artwork}
     * @memberof FeedBytag
     */
    artwork: Artwork;
    /**
     *
     * @type {LastUpdateTime}
     * @memberof FeedBytag
     */
    lastUpdateTime: LastUpdateTime;
    /**
     *
     * @type {LastCrawlTime}
     * @memberof FeedBytag
     */
    lastCrawlTime: LastCrawlTime;
    /**
     *
     * @type {LastParseTime}
     * @memberof FeedBytag
     */
    lastParseTime: LastParseTime;
    /**
     *
     * @type {LastGoodHttpStatusTime}
     * @memberof FeedBytag
     */
    lastGoodHttpStatusTime: LastGoodHttpStatusTime;
    /**
     *
     * @type {LastHttpStatus}
     * @memberof FeedBytag
     */
    lastHttpStatus: LastHttpStatus;
    /**
     *
     * @type {ContentType}
     * @memberof FeedBytag
     */
    contentType: ContentType;
    /**
     *
     * @type {ItunesIdFeed}
     * @memberof FeedBytag
     */
    itunesId: ItunesIdFeed;
    /**
     *
     * @type {Generator}
     * @memberof FeedBytag
     */
    generator: Generator;
    /**
     *
     * @type {Language}
     * @memberof FeedBytag
     */
    language: Language;
    /**
     *
     * @type {Type}
     * @memberof FeedBytag
     */
    type: Type;
    /**
     *
     * @type {Dead}
     * @memberof FeedBytag
     */
    dead: Dead;
    /**
     *
     * @type {CrawlErrors}
     * @memberof FeedBytag
     */
    crawlErrors: CrawlErrors;
    /**
     *
     * @type {ParseErrors}
     * @memberof FeedBytag
     */
    parseErrors: ParseErrors;
    /**
     *
     * @type {Categories}
     * @memberof FeedBytag
     */
    categories: Categories;
    /**
     *
     * @type {Locked}
     * @memberof FeedBytag
     */
    locked: Locked;
    /**
     *
     * @type {ImageUrlHash}
     * @memberof FeedBytag
     */
    imageUrlHash: ImageUrlHash;
    /**
     *
     * @type {Value}
     * @memberof FeedBytag
     */
    value: Value;
    /**
     *
     * @type {Funding}
     * @memberof FeedBytag
     */
    funding: Funding;
}
/**
 *
 * @export
 * @interface FeedDead
 */
export interface FeedDead {
    /**
     *
     * @type {IdFeed}
     * @memberof FeedDead
     */
    id: IdFeed;
    /**
     *
     * @type {UrlFeed}
     * @memberof FeedDead
     */
    url: UrlFeed;
}
/**
 * Known details of podcast feed
 * @export
 * @interface FeedItunes
 */
export interface FeedItunes {
    /**
     *
     * @type {IdFeed}
     * @memberof FeedItunes
     */
    id: IdFeed;
    /**
     *
     * @type {TitleFeed}
     * @memberof FeedItunes
     */
    title: TitleFeed;
    /**
     *
     * @type {UrlFeed}
     * @memberof FeedItunes
     */
    url: UrlFeed;
    /**
     *
     * @type {OriginalUrl}
     * @memberof FeedItunes
     */
    originalUrl: OriginalUrl;
    /**
     *
     * @type {LinkFeed}
     * @memberof FeedItunes
     */
    link: LinkFeed;
    /**
     *
     * @type {DescriptionFeed}
     * @memberof FeedItunes
     */
    description: DescriptionFeed;
    /**
     *
     * @type {Author}
     * @memberof FeedItunes
     */
    author: Author;
    /**
     *
     * @type {OwnerName}
     * @memberof FeedItunes
     */
    ownerName: OwnerName;
    /**
     *
     * @type {ImageFeed}
     * @memberof FeedItunes
     */
    image: ImageFeed;
    /**
     *
     * @type {Artwork}
     * @memberof FeedItunes
     */
    artwork: Artwork;
    /**
     *
     * @type {LastUpdateTime}
     * @memberof FeedItunes
     */
    lastUpdateTime: LastUpdateTime;
    /**
     *
     * @type {LastCrawlTime}
     * @memberof FeedItunes
     */
    lastCrawlTime: LastCrawlTime;
    /**
     *
     * @type {LastParseTime}
     * @memberof FeedItunes
     */
    lastParseTime: LastParseTime;
    /**
     *
     * @type {LastGoodHttpStatusTime}
     * @memberof FeedItunes
     */
    lastGoodHttpStatusTime: LastGoodHttpStatusTime;
    /**
     *
     * @type {LastHttpStatus}
     * @memberof FeedItunes
     */
    lastHttpStatus: LastHttpStatus;
    /**
     *
     * @type {ContentType}
     * @memberof FeedItunes
     */
    contentType: ContentType;
    /**
     *
     * @type {ItunesIdFeed}
     * @memberof FeedItunes
     */
    itunesId: ItunesIdFeed;
    /**
     *
     * @type {Generator}
     * @memberof FeedItunes
     */
    generator: Generator;
    /**
     *
     * @type {Language}
     * @memberof FeedItunes
     */
    language: Language;
    /**
     *
     * @type {Type}
     * @memberof FeedItunes
     */
    type: Type;
    /**
     *
     * @type {Dead}
     * @memberof FeedItunes
     */
    dead: Dead;
    /**
     *
     * @type {CrawlErrors}
     * @memberof FeedItunes
     */
    crawlErrors: CrawlErrors;
    /**
     *
     * @type {ParseErrors}
     * @memberof FeedItunes
     */
    parseErrors: ParseErrors;
    /**
     *
     * @type {Locked}
     * @memberof FeedItunes
     */
    locked: Locked;
}
/**
 * Known details of podcast feed
 * @export
 * @interface FeedPodcast
 */
export interface FeedPodcast {
    /**
     *
     * @type {IdFeed}
     * @memberof FeedPodcast
     */
    id: IdFeed;
    /**
     *
     * @type {TitleFeed}
     * @memberof FeedPodcast
     */
    title: TitleFeed;
    /**
     *
     * @type {UrlFeed}
     * @memberof FeedPodcast
     */
    url: UrlFeed;
    /**
     *
     * @type {OriginalUrl}
     * @memberof FeedPodcast
     */
    originalUrl: OriginalUrl;
    /**
     *
     * @type {LinkFeed}
     * @memberof FeedPodcast
     */
    link: LinkFeed;
    /**
     *
     * @type {DescriptionFeed}
     * @memberof FeedPodcast
     */
    description: DescriptionFeed;
    /**
     *
     * @type {Author}
     * @memberof FeedPodcast
     */
    author: Author;
    /**
     *
     * @type {OwnerName}
     * @memberof FeedPodcast
     */
    ownerName: OwnerName;
    /**
     *
     * @type {ImageFeed}
     * @memberof FeedPodcast
     */
    image: ImageFeed;
    /**
     *
     * @type {Artwork}
     * @memberof FeedPodcast
     */
    artwork: Artwork;
    /**
     *
     * @type {LastUpdateTime}
     * @memberof FeedPodcast
     */
    lastUpdateTime: LastUpdateTime;
    /**
     *
     * @type {LastCrawlTime}
     * @memberof FeedPodcast
     */
    lastCrawlTime: LastCrawlTime;
    /**
     *
     * @type {LastParseTime}
     * @memberof FeedPodcast
     */
    lastParseTime: LastParseTime;
    /**
     *
     * @type {LastGoodHttpStatusTime}
     * @memberof FeedPodcast
     */
    lastGoodHttpStatusTime: LastGoodHttpStatusTime;
    /**
     *
     * @type {LastHttpStatus}
     * @memberof FeedPodcast
     */
    lastHttpStatus: LastHttpStatus;
    /**
     *
     * @type {ContentType}
     * @memberof FeedPodcast
     */
    contentType: ContentType;
    /**
     *
     * @type {ItunesIdFeed}
     * @memberof FeedPodcast
     */
    itunesId: ItunesIdFeed;
    /**
     *
     * @type {Generator}
     * @memberof FeedPodcast
     */
    generator: Generator;
    /**
     *
     * @type {Language}
     * @memberof FeedPodcast
     */
    language: Language;
    /**
     *
     * @type {Type}
     * @memberof FeedPodcast
     */
    type: Type;
    /**
     *
     * @type {Dead}
     * @memberof FeedPodcast
     */
    dead: Dead;
    /**
     *
     * @type {Chash}
     * @memberof FeedPodcast
     */
    chash: Chash;
    /**
     *
     * @type {EpisodeCount}
     * @memberof FeedPodcast
     */
    episodeCount: EpisodeCount;
    /**
     *
     * @type {CrawlErrors}
     * @memberof FeedPodcast
     */
    crawlErrors: CrawlErrors;
    /**
     *
     * @type {ParseErrors}
     * @memberof FeedPodcast
     */
    parseErrors: ParseErrors;
    /**
     *
     * @type {Categories}
     * @memberof FeedPodcast
     */
    categories: Categories;
    /**
     *
     * @type {Locked}
     * @memberof FeedPodcast
     */
    locked: Locked;
    /**
     *
     * @type {ImageUrlHash}
     * @memberof FeedPodcast
     */
    imageUrlHash: ImageUrlHash;
    /**
     *
     * @type {Value}
     * @memberof FeedPodcast
     */
    value: Value;
    /**
     *
     * @type {Funding}
     * @memberof FeedPodcast
     */
    funding: Funding;
}
/**
 *
 * @export
 * @interface FeedSearch
 */
export interface FeedSearch {
    /**
     *
     * @type {IdFeed}
     * @memberof FeedSearch
     */
    id: IdFeed;
    /**
     *
     * @type {TitleFeed}
     * @memberof FeedSearch
     */
    title: TitleFeed;
    /**
     *
     * @type {UrlFeed}
     * @memberof FeedSearch
     */
    url: UrlFeed;
    /**
     *
     * @type {OriginalUrl}
     * @memberof FeedSearch
     */
    originalUrl: OriginalUrl;
    /**
     *
     * @type {LinkFeed}
     * @memberof FeedSearch
     */
    link: LinkFeed;
    /**
     *
     * @type {DescriptionFeed}
     * @memberof FeedSearch
     */
    description: DescriptionFeed;
    /**
     *
     * @type {Author}
     * @memberof FeedSearch
     */
    author: Author;
    /**
     *
     * @type {OwnerName}
     * @memberof FeedSearch
     */
    ownerName: OwnerName;
    /**
     *
     * @type {ImageFeed}
     * @memberof FeedSearch
     */
    image: ImageFeed;
    /**
     *
     * @type {Artwork}
     * @memberof FeedSearch
     */
    artwork: Artwork;
    /**
     *
     * @type {LastUpdateTime}
     * @memberof FeedSearch
     */
    lastUpdateTime: LastUpdateTime;
    /**
     *
     * @type {LastCrawlTime}
     * @memberof FeedSearch
     */
    lastCrawlTime: LastCrawlTime;
    /**
     *
     * @type {LastParseTime}
     * @memberof FeedSearch
     */
    lastParseTime: LastParseTime;
    /**
     *
     * @type {LastGoodHttpStatusTime}
     * @memberof FeedSearch
     */
    lastGoodHttpStatusTime: LastGoodHttpStatusTime;
    /**
     *
     * @type {LastHttpStatus}
     * @memberof FeedSearch
     */
    lastHttpStatus: LastHttpStatus;
    /**
     *
     * @type {ContentType}
     * @memberof FeedSearch
     */
    contentType: ContentType;
    /**
     *
     * @type {ItunesIdFeed}
     * @memberof FeedSearch
     */
    itunesId: ItunesIdFeed;
    /**
     *
     * @type {Generator}
     * @memberof FeedSearch
     */
    generator: Generator;
    /**
     *
     * @type {Language}
     * @memberof FeedSearch
     */
    language: Language;
    /**
     *
     * @type {Type}
     * @memberof FeedSearch
     */
    type: Type;
    /**
     *
     * @type {Dead}
     * @memberof FeedSearch
     */
    dead: Dead;
    /**
     *
     * @type {CrawlErrors}
     * @memberof FeedSearch
     */
    crawlErrors: CrawlErrors;
    /**
     *
     * @type {ParseErrors}
     * @memberof FeedSearch
     */
    parseErrors: ParseErrors;
    /**
     *
     * @type {Categories}
     * @memberof FeedSearch
     */
    categories: Categories;
    /**
     *
     * @type {Locked}
     * @memberof FeedSearch
     */
    locked: Locked;
    /**
     *
     * @type {ImageUrlHash}
     * @memberof FeedSearch
     */
    imageUrlHash: ImageUrlHash;
}
/**
 *
 * @export
 * @interface FeedTrending
 */
export interface FeedTrending {
    /**
     *
     * @type {IdFeed}
     * @memberof FeedTrending
     */
    id: IdFeed;
    /**
     *
     * @type {UrlFeed}
     * @memberof FeedTrending
     */
    url: UrlFeed;
    /**
     *
     * @type {TitleFeed}
     * @memberof FeedTrending
     */
    title: TitleFeed;
    /**
     *
     * @type {Author}
     * @memberof FeedTrending
     */
    author: Author;
    /**
     *
     * @type {ImageFeed}
     * @memberof FeedTrending
     */
    image: ImageFeed;
    /**
     *
     * @type {NewestItemPublishedTime}
     * @memberof FeedTrending
     */
    newestItemPublishedTime: NewestItemPublishedTime;
    /**
     *
     * @type {ItunesIdFeed}
     * @memberof FeedTrending
     */
    itunesId: ItunesIdFeed;
    /**
     *
     * @type {TrendScore}
     * @memberof FeedTrending
     */
    trendScore: TrendScore;
    /**
     *
     * @type {Language}
     * @memberof FeedTrending
     */
    language: Language;
    /**
     *
     * @type {Categories}
     * @memberof FeedTrending
     */
    categories: Categories;
}
/**
 * List of feeds matching request
 * @export
 * @interface Feeds
 */
export interface Feeds extends Array<FeedSearch> {
}
/**
 * List of feeds matching request
 * @export
 * @interface FeedsBytag
 */
export interface FeedsBytag extends Array<FeedBytag> {
}
/**
 * List of feeds matching request
 * @export
 * @interface FeedsDead
 */
export interface FeedsDead extends Array<FeedDead> {
}
/**
 * List of feeds matching request
 * @export
 * @interface FeedsRecent
 */
export interface FeedsRecent extends Array<FeedsRecentInner> {
}
/**
 *
 * @export
 * @interface FeedsRecentInner
 */
export interface FeedsRecentInner {
    /**
     *
     * @type {IdFeed}
     * @memberof FeedsRecentInner
     */
    id: IdFeed;
    /**
     *
     * @type {UrlFeed}
     * @memberof FeedsRecentInner
     */
    url: UrlFeed;
    /**
     *
     * @type {TitleFeed}
     * @memberof FeedsRecentInner
     */
    title: TitleFeed;
    /**
     *
     * @type {NewestItemPublishedTime}
     * @memberof FeedsRecentInner
     */
    newestItemPublishedTime: NewestItemPublishedTime;
    /**
     *
     * @type {ItunesIdFeed}
     * @memberof FeedsRecentInner
     */
    itunesId: ItunesIdFeed;
    /**
     *
     * @type {Language}
     * @memberof FeedsRecentInner
     */
    language: Language;
    /**
     *
     * @type {Categories}
     * @memberof FeedsRecentInner
     */
    categories: Categories;
}
/**
 * List of feeds matching request
 * @export
 * @interface FeedsRecentNew
 */
export interface FeedsRecentNew extends Array<FeedsRecentNewInner> {
}
/**
 *
 * @export
 * @interface FeedsRecentNewInner
 */
export interface FeedsRecentNewInner {
    /**
     *
     * @type {IdFeed}
     * @memberof FeedsRecentNewInner
     */
    id: IdFeed;
    /**
     *
     * @type {UrlFeed}
     * @memberof FeedsRecentNewInner
     */
    url: UrlFeed;
    /**
     *
     * @type {TimeAdded}
     * @memberof FeedsRecentNewInner
     */
    timeAdded: TimeAdded;
    /**
     *
     * @type {StatusFeed}
     * @memberof FeedsRecentNewInner
     */
    status: StatusFeed;
    /**
     *
     * @type {ContentHash}
     * @memberof FeedsRecentNewInner
     */
    contentHash: ContentHash;
    /**
     *
     * @type {Language}
     * @memberof FeedsRecentNewInner
     */
    language: Language;
}
/**
 * List of feeds matching request
 * @export
 * @interface FeedsTrending
 */
export interface FeedsTrending extends Array<FeedTrending> {
}
/**
 * Information for donation/funding the podcast.  See the [podcast namespace spec](https://podcastindex.org/namespace/1.0#funding) for more information.
 * @export
 * @interface Funding
 */
export interface Funding {
    /**
     *
     * @type {UrlFunding}
     * @memberof Funding
     */
    url: UrlFunding;
    /**
     *
     * @type {Message}
     * @memberof Funding
     */
    message: Message;
}
/**
 * The channel-level generator element if there is one.
 * @export
 * @interface Generator
 */
export interface Generator {
}
/**
 * The unique identifier for the episode
 * @export
 * @interface Guid
 */
export interface Guid {
}
/**
 * The internal PodcastIndex.org episode ID.
 * @export
 * @interface IdEpisode
 */
export interface IdEpisode {
}
/**
 * The internal PodcastIndex.org Feed ID.
 * @export
 * @interface IdFeed
 */
export interface IdFeed {
}
/**
 * Value passed to request in the `id` field
 * @export
 * @interface IdQuery
 */
export interface IdQuery {
}
/**
 * The item-level image for the episode
 * @export
 * @interface ImageEpisode
 */
export interface ImageEpisode {
}
/**
 * The channel-level image element.
 * @export
 * @interface ImageFeed
 */
export interface ImageFeed {
}
/**
 * A CRC32 hash of the `image` URL with the protocol (`http://`, `https://`) removed. Can be used to retrieve a resized/converted version of the image specified by `image` from https://podcastimages.com/.  Using the format: `https://podcastimages.com/<hash>_<size>.jpg` Replace `<hash>` with the value in this field. The `<size>` is the desired image width/height. Ex: `https://podcastimages.com/1011338142_600.jpg`  **Work in Progress**: the `podcastimages.com` system is currently not working.
 * @export
 * @interface ImageUrlHash
 */
export interface ImageUrlHash {
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse200
     */
    status: Status;
    /**
     *
     * @type {Feeds}
     * @memberof InlineResponse200
     */
    feeds: Feeds;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse200
     */
    count: Count;
    /**
     *
     * @type {QuerySearch}
     * @memberof InlineResponse200
     */
    query: QuerySearch;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse200
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse2001
     */
    status: Status;
    /**
     *
     * @type {ItemsByperson}
     * @memberof InlineResponse2001
     */
    items: ItemsByperson;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse2001
     */
    count: Count;
    /**
     *
     * @type {QuerySearch}
     * @memberof InlineResponse2001
     */
    query: QuerySearch;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse2001
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20010
     */
    status: Status;
    /**
     *
     * @type {ItemsPodcast}
     * @memberof InlineResponse20010
     */
    items: ItemsPodcast;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse20010
     */
    count: Count;
    /**
     *
     * @type {IdQuery}
     * @memberof InlineResponse20010
     */
    query: IdQuery;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20010
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20011
     */
    status: Status;
    /**
     *
     * @type {IdEpisode}
     * @memberof InlineResponse20011
     */
    id: IdEpisode;
    /**
     *
     * @type {EpisodeObject}
     * @memberof InlineResponse20011
     */
    episode: EpisodeObject;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20011
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20012
     */
    status: Status;
    /**
     *
     * @type {EpisodesRandomArray}
     * @memberof InlineResponse20012
     */
    episodes: EpisodesRandomArray;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse20012
     */
    count: Count;
    /**
     *
     * @type {Max}
     * @memberof InlineResponse20012
     */
    max: Max;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20012
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20013
     */
    status: Status;
    /**
     *
     * @type {ItemsRecent}
     * @memberof InlineResponse20013
     */
    items: ItemsRecent;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse20013
     */
    count: Count;
    /**
     *
     * @type {Max}
     * @memberof InlineResponse20013
     */
    max: Max;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20013
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20014
     */
    status: Status;
    /**
     *
     * @type {FeedsRecent}
     * @memberof InlineResponse20014
     */
    feeds: FeedsRecent;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse20014
     */
    count: Count;
    /**
     *
     * @type {Max}
     * @memberof InlineResponse20014
     */
    max: Max;
    /**
     *
     * @type {Since}
     * @memberof InlineResponse20014
     */
    since: Since;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20014
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20015
     */
    status: Status;
    /**
     *
     * @type {FeedsRecentNew}
     * @memberof InlineResponse20015
     */
    feeds: FeedsRecentNew;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse20015
     */
    count: Count;
    /**
     *
     * @type {Max}
     * @memberof InlineResponse20015
     */
    max: Max;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20015
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20016
     */
    status: Status;
    /**
     *
     * @type {ItemsSoundbites}
     * @memberof InlineResponse20016
     */
    items: ItemsSoundbites;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse20016
     */
    count: Count;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20016
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20017
     */
    status: Status;
    /**
     *
     * @type {QueryId}
     * @memberof InlineResponse20017
     */
    query: QueryId;
    /**
     *
     * @type {Value}
     * @memberof InlineResponse20017
     */
    value: Value;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20017
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20018
     */
    status: Status;
    /**
     *
     * @type {QueryUrl}
     * @memberof InlineResponse20018
     */
    query: QueryUrl;
    /**
     *
     * @type {Value}
     * @memberof InlineResponse20018
     */
    value: Value;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20018
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20019
     */
    status: Status;
    /**
     *
     * @type {Stats}
     * @memberof InlineResponse20019
     */
    stats: Stats;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20019
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse2002
     */
    status: Status;
    /**
     *
     * @type {QueryId}
     * @memberof InlineResponse2002
     */
    query: QueryId;
    /**
     *
     * @type {FeedPodcast}
     * @memberof InlineResponse2002
     */
    feed: FeedPodcast;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse2002
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20020
     */
    status: Status;
    /**
     *
     * @type {IdFeed}
     * @memberof InlineResponse20020
     */
    feedId: IdFeed;
    /**
     *
     * @type {Existed}
     * @memberof InlineResponse20020
     */
    existed: Existed;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20020
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse20021
     */
    status: Status;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse20021
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse2003
     */
    status: Status;
    /**
     *
     * @type {QueryUrl}
     * @memberof InlineResponse2003
     */
    query: QueryUrl;
    /**
     *
     * @type {FeedPodcast}
     * @memberof InlineResponse2003
     */
    feed: FeedPodcast;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse2003
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse2004
     */
    status: Status;
    /**
     *
     * @type {QueryId}
     * @memberof InlineResponse2004
     */
    query: QueryId;
    /**
     *
     * @type {FeedItunes}
     * @memberof InlineResponse2004
     */
    feed: FeedItunes;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse2004
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse2005
     */
    status: Status;
    /**
     *
     * @type {FeedsBytag}
     * @memberof InlineResponse2005
     */
    feeds: FeedsBytag;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse2005
     */
    count: Count;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse2005
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse2006
     */
    status: Status;
    /**
     *
     * @type {FeedsTrending}
     * @memberof InlineResponse2006
     */
    feeds: FeedsTrending;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse2006
     */
    count: Count;
    /**
     *
     * @type {Max}
     * @memberof InlineResponse2006
     */
    max: Max;
    /**
     *
     * @type {Since}
     * @memberof InlineResponse2006
     */
    since: Since;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse2006
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse2007
     */
    status: Status;
    /**
     *
     * @type {FeedsDead}
     * @memberof InlineResponse2007
     */
    feeds: FeedsDead;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse2007
     */
    count: Count;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse2007
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse2008
     */
    status: Status;
    /**
     *
     * @type {ItemsPodcast}
     * @memberof InlineResponse2008
     */
    items: ItemsPodcast;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse2008
     */
    count: Count;
    /**
     *
     * @type {QueryPodcastIdSingle | QueryPodcastIdMultiple}
     * @memberof InlineResponse2008
     */
    query: QueryPodcastIdSingle | QueryPodcastIdMultiple;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse2008
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     *
     * @type {Status}
     * @memberof InlineResponse2009
     */
    status: Status;
    /**
     *
     * @type {ItemsPodcast}
     * @memberof InlineResponse2009
     */
    items: ItemsPodcast;
    /**
     *
     * @type {Count}
     * @memberof InlineResponse2009
     */
    count: Count;
    /**
     *
     * @type {QueryUrl}
     * @memberof InlineResponse2009
     */
    query: QueryUrl;
    /**
     *
     * @type {DescriptionResponse}
     * @memberof InlineResponse2009
     */
    description: DescriptionResponse;
}
/**
 *
 * @export
 * @interface ItemPodcast
 */
export interface ItemPodcast {
    /**
     *
     * @type {IdEpisode}
     * @memberof ItemPodcast
     */
    id: IdEpisode;
    /**
     *
     * @type {TitleFeed}
     * @memberof ItemPodcast
     */
    title: TitleFeed;
    /**
     *
     * @type {LinkFeed}
     * @memberof ItemPodcast
     */
    link: LinkFeed;
    /**
     *
     * @type {DescriptionEpisode}
     * @memberof ItemPodcast
     */
    description: DescriptionEpisode;
    /**
     *
     * @type {Guid}
     * @memberof ItemPodcast
     */
    guid: Guid;
    /**
     *
     * @type {DatePublished}
     * @memberof ItemPodcast
     */
    datePublished: DatePublished;
    /**
     *
     * @type {DatePublishedPretty}
     * @memberof ItemPodcast
     */
    datePublishedPretty: DatePublishedPretty;
    /**
     *
     * @type {DateCrawled}
     * @memberof ItemPodcast
     */
    dateCrawled: DateCrawled;
    /**
     *
     * @type {EnclosureUrl}
     * @memberof ItemPodcast
     */
    enclosureUrl: EnclosureUrl;
    /**
     *
     * @type {EnclosureType}
     * @memberof ItemPodcast
     */
    enclosureType: EnclosureType;
    /**
     *
     * @type {EnclosureLength}
     * @memberof ItemPodcast
     */
    enclosureLength: EnclosureLength;
    /**
     *
     * @type {Duration}
     * @memberof ItemPodcast
     */
    duration: Duration;
    /**
     *
     * @type {Explicit}
     * @memberof ItemPodcast
     */
    explicit: Explicit;
    /**
     *
     * @type {EpisodeNumber}
     * @memberof ItemPodcast
     */
    episode: EpisodeNumber;
    /**
     *
     * @type {EpisodeType}
     * @memberof ItemPodcast
     */
    episodeType: EpisodeType;
    /**
     *
     * @type {Season}
     * @memberof ItemPodcast
     */
    season: Season;
    /**
     *
     * @type {ImageEpisode}
     * @memberof ItemPodcast
     */
    image: ImageEpisode;
    /**
     *
     * @type {ItunesIdFeed}
     * @memberof ItemPodcast
     */
    feedItunesId: ItunesIdFeed;
    /**
     *
     * @type {ImageFeed}
     * @memberof ItemPodcast
     */
    feedImage: ImageFeed;
    /**
     *
     * @type {IdFeed}
     * @memberof ItemPodcast
     */
    feedId: IdFeed;
    /**
     *
     * @type {Language}
     * @memberof ItemPodcast
     */
    feedLanguage: Language;
    /**
     *
     * @type {ChaptersUrl}
     * @memberof ItemPodcast
     */
    chaptersUrl: ChaptersUrl;
    /**
     *
     * @type {TranscriptUrl}
     * @memberof ItemPodcast
     */
    transcriptUrl: TranscriptUrl;
    /**
     *
     * @type {Soundbite}
     * @memberof ItemPodcast
     */
    soundbite: Soundbite;
    /**
     *
     * @type {Soundbites}
     * @memberof ItemPodcast
     */
    soundbites: Soundbites;
}
/**
 *
 * @export
 * @interface ItemPodcastRandom
 */
export interface ItemPodcastRandom {
    /**
     *
     * @type {IdEpisode}
     * @memberof ItemPodcastRandom
     */
    id: IdEpisode;
    /**
     *
     * @type {TitleFeed}
     * @memberof ItemPodcastRandom
     */
    title: TitleFeed;
    /**
     *
     * @type {LinkFeed}
     * @memberof ItemPodcastRandom
     */
    link: LinkFeed;
    /**
     *
     * @type {DescriptionEpisode}
     * @memberof ItemPodcastRandom
     */
    description: DescriptionEpisode;
    /**
     *
     * @type {Guid}
     * @memberof ItemPodcastRandom
     */
    guid: Guid;
    /**
     *
     * @type {DatePublished}
     * @memberof ItemPodcastRandom
     */
    datePublished: DatePublished;
    /**
     *
     * @type {DatePublishedPretty}
     * @memberof ItemPodcastRandom
     */
    datePublishedPretty: DatePublishedPretty;
    /**
     *
     * @type {DateCrawled}
     * @memberof ItemPodcastRandom
     */
    dateCrawled: DateCrawled;
    /**
     *
     * @type {EnclosureUrl}
     * @memberof ItemPodcastRandom
     */
    enclosureUrl: EnclosureUrl;
    /**
     *
     * @type {EnclosureType}
     * @memberof ItemPodcastRandom
     */
    enclosureType: EnclosureType;
    /**
     *
     * @type {EnclosureLength}
     * @memberof ItemPodcastRandom
     */
    enclosureLength: EnclosureLength;
    /**
     *
     * @type {Explicit}
     * @memberof ItemPodcastRandom
     */
    explicit: Explicit;
    /**
     *
     * @type {EpisodeNumber}
     * @memberof ItemPodcastRandom
     */
    episode: EpisodeNumber;
    /**
     *
     * @type {EpisodeType}
     * @memberof ItemPodcastRandom
     */
    episodeType: EpisodeType;
    /**
     *
     * @type {Season}
     * @memberof ItemPodcastRandom
     */
    season: Season;
    /**
     *
     * @type {ImageEpisode}
     * @memberof ItemPodcastRandom
     */
    image: ImageEpisode;
    /**
     *
     * @type {ItunesIdFeed}
     * @memberof ItemPodcastRandom
     */
    feedItunesId: ItunesIdFeed;
    /**
     *
     * @type {ImageFeed}
     * @memberof ItemPodcastRandom
     */
    feedImage: ImageFeed;
    /**
     *
     * @type {IdFeed}
     * @memberof ItemPodcastRandom
     */
    feedId: IdFeed;
    /**
     *
     * @type {TitleFeed}
     * @memberof ItemPodcastRandom
     */
    feedTitle: TitleFeed;
    /**
     *
     * @type {Language}
     * @memberof ItemPodcastRandom
     */
    feedLanguage: Language;
    /**
     *
     * @type {Categories}
     * @memberof ItemPodcastRandom
     */
    categories: Categories;
    /**
     *
     * @type {ChaptersUrl}
     * @memberof ItemPodcastRandom
     */
    chaptersUrl: ChaptersUrl;
}
/**
 *
 * @export
 * @interface ItemPodcastRecent
 */
export interface ItemPodcastRecent {
    /**
     *
     * @type {IdEpisode}
     * @memberof ItemPodcastRecent
     */
    id: IdEpisode;
    /**
     *
     * @type {TitleFeed}
     * @memberof ItemPodcastRecent
     */
    title: TitleFeed;
    /**
     *
     * @type {LinkFeed}
     * @memberof ItemPodcastRecent
     */
    link: LinkFeed;
    /**
     *
     * @type {DescriptionEpisode}
     * @memberof ItemPodcastRecent
     */
    description: DescriptionEpisode;
    /**
     *
     * @type {Guid}
     * @memberof ItemPodcastRecent
     */
    guid: Guid;
    /**
     *
     * @type {DatePublished}
     * @memberof ItemPodcastRecent
     */
    datePublished: DatePublished;
    /**
     *
     * @type {DatePublishedPretty}
     * @memberof ItemPodcastRecent
     */
    datePublishedPretty: DatePublishedPretty;
    /**
     *
     * @type {DateCrawled}
     * @memberof ItemPodcastRecent
     */
    dateCrawled: DateCrawled;
    /**
     *
     * @type {EnclosureUrl}
     * @memberof ItemPodcastRecent
     */
    enclosureUrl: EnclosureUrl;
    /**
     *
     * @type {EnclosureType}
     * @memberof ItemPodcastRecent
     */
    enclosureType: EnclosureType;
    /**
     *
     * @type {EnclosureLength}
     * @memberof ItemPodcastRecent
     */
    enclosureLength: EnclosureLength;
    /**
     *
     * @type {Explicit}
     * @memberof ItemPodcastRecent
     */
    explicit: Explicit;
    /**
     *
     * @type {EpisodeNumber}
     * @memberof ItemPodcastRecent
     */
    episode: EpisodeNumber;
    /**
     *
     * @type {EpisodeType}
     * @memberof ItemPodcastRecent
     */
    episodeType: EpisodeType;
    /**
     *
     * @type {Season}
     * @memberof ItemPodcastRecent
     */
    season: Season;
    /**
     *
     * @type {ImageEpisode}
     * @memberof ItemPodcastRecent
     */
    image: ImageEpisode;
    /**
     *
     * @type {ItunesIdFeed}
     * @memberof ItemPodcastRecent
     */
    feedItunesId: ItunesIdFeed;
    /**
     *
     * @type {ImageFeed}
     * @memberof ItemPodcastRecent
     */
    feedImage: ImageFeed;
    /**
     *
     * @type {IdFeed}
     * @memberof ItemPodcastRecent
     */
    feedId: IdFeed;
    /**
     *
     * @type {TitleFeed}
     * @memberof ItemPodcastRecent
     */
    feedTitle: TitleFeed;
    /**
     *
     * @type {Language}
     * @memberof ItemPodcastRecent
     */
    feedLanguage: Language;
}
/**
 *
 * @export
 * @interface ItemSearchByperson
 */
export interface ItemSearchByperson {
    /**
     *
     * @type {IdEpisode}
     * @memberof ItemSearchByperson
     */
    id: IdEpisode;
    /**
     *
     * @type {TitleFeed}
     * @memberof ItemSearchByperson
     */
    title: TitleFeed;
    /**
     *
     * @type {LinkFeed}
     * @memberof ItemSearchByperson
     */
    link: LinkFeed;
    /**
     *
     * @type {DescriptionEpisode}
     * @memberof ItemSearchByperson
     */
    description: DescriptionEpisode;
    /**
     *
     * @type {Guid}
     * @memberof ItemSearchByperson
     */
    guid: Guid;
    /**
     *
     * @type {DatePublished}
     * @memberof ItemSearchByperson
     */
    datePublished: DatePublished;
    /**
     *
     * @type {DateCrawled}
     * @memberof ItemSearchByperson
     */
    dateCrawled: DateCrawled;
    /**
     *
     * @type {EnclosureUrl}
     * @memberof ItemSearchByperson
     */
    enclosureUrl: EnclosureUrl;
    /**
     *
     * @type {EnclosureType}
     * @memberof ItemSearchByperson
     */
    enclosureType: EnclosureType;
    /**
     *
     * @type {EnclosureLength}
     * @memberof ItemSearchByperson
     */
    enclosureLength: EnclosureLength;
    /**
     *
     * @type {Duration}
     * @memberof ItemSearchByperson
     */
    duration: Duration;
    /**
     *
     * @type {Explicit}
     * @memberof ItemSearchByperson
     */
    explicit: Explicit;
    /**
     *
     * @type {EpisodeNumber}
     * @memberof ItemSearchByperson
     */
    episode: EpisodeNumber;
    /**
     *
     * @type {EpisodeType}
     * @memberof ItemSearchByperson
     */
    episodeType: EpisodeType;
    /**
     *
     * @type {Season}
     * @memberof ItemSearchByperson
     */
    season: Season;
    /**
     *
     * @type {ImageEpisode}
     * @memberof ItemSearchByperson
     */
    image: ImageEpisode;
    /**
     *
     * @type {ItunesIdFeed}
     * @memberof ItemSearchByperson
     */
    feedItunesId: ItunesIdFeed;
    /**
     *
     * @type {ImageFeed}
     * @memberof ItemSearchByperson
     */
    feedImage: ImageFeed;
    /**
     *
     * @type {IdFeed}
     * @memberof ItemSearchByperson
     */
    feedId: IdFeed;
    /**
     *
     * @type {UrlFeed}
     * @memberof ItemSearchByperson
     */
    feedUrl: UrlFeed;
    /**
     *
     * @type {Author}
     * @memberof ItemSearchByperson
     */
    feedAuthor: Author;
    /**
     *
     * @type {TitleFeed}
     * @memberof ItemSearchByperson
     */
    feedTitle: TitleFeed;
    /**
     *
     * @type {Language}
     * @memberof ItemSearchByperson
     */
    feedLanguage: Language;
    /**
     *
     * @type {ChaptersUrl}
     * @memberof ItemSearchByperson
     */
    chaptersUrl: ChaptersUrl;
    /**
     *
     * @type {TranscriptUrl}
     * @memberof ItemSearchByperson
     */
    transcriptUrl: TranscriptUrl;
}
/**
 * List of episodes matching request
 * @export
 * @interface ItemsByperson
 */
export interface ItemsByperson extends Array<ItemSearchByperson> {
}
/**
 * List of episodes matching request
 * @export
 * @interface ItemsPodcast
 */
export interface ItemsPodcast extends Array<ItemPodcast> {
}
/**
 * List of episodes matching request
 * @export
 * @interface ItemsRecent
 */
export interface ItemsRecent extends Array<ItemPodcastRecent> {
}
/**
 * List of soundbites matching request
 * @export
 * @interface ItemsSoundbites
 */
export interface ItemsSoundbites extends Array<ItemsSoundbitesInner> {
}
/**
 *
 * @export
 * @interface ItemsSoundbitesInner
 */
export interface ItemsSoundbitesInner {
    /**
     *
     * @type {EnclosureUrl}
     * @memberof ItemsSoundbitesInner
     */
    enclosureUrl: EnclosureUrl;
    /**
     *
     * @type {TitleSoundbite}
     * @memberof ItemsSoundbitesInner
     */
    title: TitleSoundbite;
    /**
     *
     * @type {StartTime}
     * @memberof ItemsSoundbitesInner
     */
    startTime: StartTime;
    /**
     *
     * @type {DurationSoundbite}
     * @memberof ItemsSoundbitesInner
     */
    duration: DurationSoundbite;
    /**
     *
     * @type {IdEpisode}
     * @memberof ItemsSoundbitesInner
     */
    episodeId: IdEpisode;
    /**
     *
     * @type {TitleEpisode}
     * @memberof ItemsSoundbitesInner
     */
    episodeTitle: TitleEpisode;
    /**
     *
     * @type {TitleFeed}
     * @memberof ItemsSoundbitesInner
     */
    feedTitle: TitleFeed;
    /**
     *
     * @type {UrlFeed}
     * @memberof ItemsSoundbitesInner
     */
    feedUrl: UrlFeed;
    /**
     *
     * @type {IdFeed}
     * @memberof ItemsSoundbitesInner
     */
    feedId: IdFeed;
}
/**
 * The iTunes ID of this feed if there is one, and we know what it is.
 * @export
 * @interface ItunesIdFeed
 */
export interface ItunesIdFeed {
}
/**
 * The channel-level language specification of the feed. Languages accord with the [RSS Language Spec](https://www.rssboard.org/rss-language-codes).
 * @export
 * @interface Language
 */
export interface Language {
}
/**
 * The last time we attempted to pull this feed from its url.
 * @export
 * @interface LastCrawlTime
 */
export interface LastCrawlTime {
}
/**
 * Timestamp of the last time we got a \"good\", meaning non-4xx/non-5xx, status code when pulling this feed from its url.
 * @export
 * @interface LastGoodHttpStatusTime
 */
export interface LastGoodHttpStatusTime {
}
/**
 * The last http status code we got when pulling this feed from its url.  You will see some made up status codes sometimes. These are what we use to track state within the feed puller. These all start with 9xx.
 * @export
 * @interface LastHttpStatus
 */
export interface LastHttpStatus {
}
/**
 * The last time we tried to parse the downloaded feed content.
 * @export
 * @interface LastParseTime
 */
export interface LastParseTime {
}
/**
 * The channel-level pubDate for the feed, if it’s sane. If not, this is a heuristic value, arrived at by analyzing other parts of the feed, like item-level pubDates.
 * @export
 * @interface LastUpdateTime
 */
export interface LastUpdateTime {
}
/**
 * The channel-level link in the feed
 * @export
 * @interface LinkFeed
 */
export interface LinkFeed {
}
/**
 * Tell other podcast platforms whether they are allowed to import this feed. A value of 1 means that any attempt to import this feed into a new platform should be rejected. Contains the value of the feed's channel-level `podcast:locked` tag where:    - 0: 'no'   - 1: 'yes'
 * @export
 * @enum {string}
 */
export const Locked = {
    NUMBER_0:0,
    NUMBER_1:1
} as const

export type Locked = typeof Locked[keyof typeof Locked]
/**
 * Value of `max` parameter passed to request.
 * @export
 * @interface Max
 */
export interface Max {
}
/**
 * Description of `url`  See the [podcast namespace spec](https://podcastindex.org/namespace/1.0#funding) for more information.
 * @export
 * @interface Message
 */
export interface Message {
}
/**
 * Method for sending payment
 * @export
 * @interface MethodV4v
 */
export interface MethodV4v {
}
/**
 * Description of the method for providing \"Value for Value\" payments
 * @export
 * @interface ModelV4v
 */
export interface ModelV4v {
    /**
     *
     * @type {TypeV4v}
     * @memberof ModelV4v
     */
    type: TypeV4v;
    /**
     *
     * @type {MethodV4v}
     * @memberof ModelV4v
     */
    method: MethodV4v;
    /**
     *
     * @type {SuggestedV4v}
     * @memberof ModelV4v
     */
    suggested: SuggestedV4v;
}
/**
 * Name for the destination
 * @export
 * @interface NameDestination
 */
export interface NameDestination {
}
/**
 * The date and time the most recent episode in the feed was published
 * @export
 * @interface NewestItemPublishedTime
 */
export interface NewestItemPublishedTime {
}
/**
 * The URL of the feed, before it changed to the current `url` value.
 * @export
 * @interface OriginalUrl
 */
export interface OriginalUrl {
}
/**
 * The channel-level owner:name element.  Usually iTunes specific, but could be from another namespace if not present.
 * @export
 * @interface OwnerName
 */
export interface OwnerName {
}
/**
 * The number of errors we’ve encountered trying to parse the feed content. Errors here are things like not well-formed xml, bad character encoding, etc.  We fix many of these types of issues on the fly when parsing. We only increment the errors count when we can’t fix it.
 * @export
 * @interface ParseErrors
 */
export interface ParseErrors {
}
/**
 * Object containing the input query data
 * @export
 * @interface QueryId
 */
export interface QueryId {
    /**
     *
     * @type {IdQuery}
     * @memberof QueryId
     */
    id: IdQuery;
}
/**
 * IDs passed to request
 * @export
 * @interface QueryPodcastIdMultiple
 */
export interface QueryPodcastIdMultiple extends Array<string> {
}
/**
 * Single ID passed to request
 * @export
 * @interface QueryPodcastIdSingle
 */
export interface QueryPodcastIdSingle {
}
/**
 * Search terms passed to request
 * @export
 * @interface QuerySearch
 */
export interface QuerySearch {
}
/**
 * Object containing the input query data
 * @export
 * @interface QueryUrl
 */
export interface QueryUrl {
    /**
     *
     * @type {UrlQuery}
     * @memberof QueryUrl
     */
    url: UrlQuery;
}
/**
 * Season number
 * @export
 * @interface Season
 */
export interface Season {
}
/**
 * Value of `since` parameter passed to request.
 * @export
 * @interface Since
 */
export interface Since {
}
/**
 * Soundbite for episode
 * @export
 * @interface Soundbite
 */
export interface Soundbite {
    /**
     *
     * @type {StartTime}
     * @memberof Soundbite
     */
    startTime: StartTime;
    /**
     *
     * @type {DurationSoundbite}
     * @memberof Soundbite
     */
    duration: DurationSoundbite;
    /**
     *
     * @type {TitleSoundbite}
     * @memberof Soundbite
     */
    title: TitleSoundbite;
}
/**
 * Soundbites for episode
 * @export
 * @interface Soundbites
 */
export interface Soundbites extends Array<Soundbite> {
}
/**
 * Share of payment the destination should receive
 * @export
 * @interface SplitDestination
 */
export interface SplitDestination {
}
/**
 * The time where the soundbite begins in the item specified by the `enclosureUrl`
 * @export
 * @interface StartTime
 */
export interface StartTime {
}
/**
 * An array statistic properties
 * @export
 * @interface Stats
 */
export interface Stats {
    /**
     * Total podcast feeds in the index.
     * @type {number}
     * @memberof Stats
     */
    feedCountTotal: number;
    /**
     * Total individual podcast episodes in the index.
     * @type {number}
     * @memberof Stats
     */
    episodeCountTotal: number;
    /**
     * Podcast feeds with a new episode released in the last 3 days.
     * @type {number}
     * @memberof Stats
     */
    feedsWithNewEpisodes3days: number;
    /**
     * Podcast feeds with a new episode released in the last 10 days.
     * @type {number}
     * @memberof Stats
     */
    feedsWithNewEpisodes10days: number;
    /**
     * Podcast feeds with a new episode released in the last 30 days.
     * @type {number}
     * @memberof Stats
     */
    feedsWithNewEpisodes30days: number;
    /**
     * Podcast feeds with a new episode released in the last 90 days.
     * @type {number}
     * @memberof Stats
     */
    feedsWithNewEpisodes90days: number;
}
/**
 * Indicates API request status
 * @export
 * @enum {string}
 */
export const Status = {
    True:'true',
    False:'false'
} as const

export type Status = typeof Status[keyof typeof Status]
/**
 * Status of feed after being added to index
 * @export
 * @enum {string}
 */
export const StatusFeed = {
    Unconfirmed:'unconfirmed',
    Confirmed:'confirmed'
} as const

export type StatusFeed = typeof StatusFeed[keyof typeof StatusFeed]
/**
 * Suggested amount per second of playback to send. Unit is specific to the `type`.
 * @export
 * @interface SuggestedV4v
 */
export interface SuggestedV4v {
}
/**
 * The date and time the feed was added to the index
 * @export
 * @interface TimeAdded
 */
export interface TimeAdded {
}
/**
 * Name of the episode
 * @export
 * @interface TitleEpisode
 */
export interface TitleEpisode {
}
/**
 * Name of the feed
 * @export
 * @interface TitleFeed
 */
export interface TitleFeed {
}
/**
 * Name of the soundbite
 * @export
 * @interface TitleSoundbite
 */
export interface TitleSoundbite {
}
/**
 * Link to the file containing the episode transcript
 * @export
 * @interface TranscriptUrl
 */
export interface TranscriptUrl {
}
/**
 * The ranking for how the podcast is trending in the index
 * @export
 * @interface TrendScore
 */
export interface TrendScore {
}
/**
 * Type of source feed where:    - 0: RSS   - 1: Atom
 * @export
 * @enum {string}
 */
export const Type = {
    NUMBER_0:0,
    NUMBER_1:1
} as const

export type Type = typeof Type[keyof typeof Type]
/**
 * Type of destination
 * @export
 * @enum {string}
 */
export const TypeDestination = {
    Node:'node'
} as const

export type TypeDestination = typeof TypeDestination[keyof typeof TypeDestination]
/**
 * Payment type
 * @export
 * @enum {string}
 */
export const TypeV4v = {
    Lightning:'lightning',
    Hive:'hive',
    Webmonetization:'webmonetization'
} as const

export type TypeV4v = typeof TypeV4v[keyof typeof TypeV4v]
/**
 * Current feed URL
 * @export
 * @interface UrlFeed
 */
export interface UrlFeed {
}
/**
 * URL to site to fund the podcast  See the [podcast namespace spec](https://podcastindex.org/namespace/1.0#funding) for more information.
 * @export
 * @interface UrlFunding
 */
export interface UrlFunding {
}
/**
 * Value passed to request in the `url` field
 * @export
 * @interface UrlQuery
 */
export interface UrlQuery {
}
/**
 * Information for supporting the podcast via one of the \"Value for Value\" methods.  Examples:   - `lightning` value type: https://api.podcastindex.org/api/1.0/podcasts/byfeedid?id=169991&pretty   - `webmonetization` value type: https://api.podcastindex.org/api/1.0/podcasts/byfeedid?id=779873&pretty
 * @export
 * @interface Value
 */
export interface Value {
    /**
     *
     * @type {ModelV4v}
     * @memberof Value
     */
    model: ModelV4v;
    /**
     *
     * @type {DestinationsV4v}
     * @memberof Value
     */
    destinations: DestinationsV4v;
}

export class Controllers {
        AddApi: AddApiApi
        EpisodesApi: EpisodesApiApi
        PodcastsApi: PodcastsApiApi
        RecentApi: RecentApiApi
        SearchApi: SearchApiApi
        StatsApi: StatsApiApi
        ValueApi: ValueApiApi

    constructor(...args) {
        this.AddApi = new AddApiApi(...args)
        this.EpisodesApi = new EpisodesApiApi(...args)
        this.PodcastsApi = new PodcastsApiApi(...args)
        this.RecentApi = new RecentApiApi(...args)
        this.SearchApi = new SearchApiApi(...args)
        this.StatsApi = new StatsApiApi(...args)
        this.ValueApi = new ValueApiApi(...args)
    }
    initialize(config) {
        this.AddApi.initialize(config)
        this.EpisodesApi.initialize(config)
        this.PodcastsApi.initialize(config)
        this.RecentApi.initialize(config)
        this.SearchApi.initialize(config)
        this.StatsApi.initialize(config)
        this.ValueApi.initialize(config)
    }
}


export class AddApiApi extends RESTDataSource {
    constructor(baseUrl?: string) {
        super();
        this.baseURL = baseUrl;
    }
    paramCreator = AddApiFetchParamCreator()
    addbyfeedurlGet(url: string, chash: string, itunesid?: number, pretty?: boolean, ): Promise<InlineResponse20020> {
        const args = this.paramCreator.addbyfeedurlGet(url, chash, itunesid, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    addbyfeedurlPost(url: string, itunesid?: number, pretty?: boolean, ): Promise<InlineResponse20020> {
        const args = this.paramCreator.addbyfeedurlPost(url, itunesid, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    addbyitunesidGet(id?: number, pretty?: boolean, ): Promise<InlineResponse20021> {
        const args = this.paramCreator.addbyitunesidGet(id, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    addbyitunesidPost(id?: number, pretty?: boolean, ): Promise<InlineResponse20021> {
        const args = this.paramCreator.addbyitunesidPost(id, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
}


/**
 * AddApi - fetch parameter creator
 * @export
 */
export const AddApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This call adds a podcast to the index using its feed url. If a feed already exists, you will get its existing Feed ID returned.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {string} chash The md5 hash of the following feed items in hex format. If known, allows for easier duplicate checking.    - &#x60;title&#x60;   - &#x60;link&#x60;   - &#x60;feedLanguage&#x60;   - &#x60;generator&#x60;   - &#x60;author&#x60;   - &#x60;ownerName&#x60;   - &#x60;ownerEmail&#x60; (note: not exposed via the API)  Pseudo-code:        chash &#x3D; md5(title+link+feedLanguage+generator+author+ownerName+ownerEmail)
         * @param {number} [itunesid] If this parameter is given, and the existing feed has no associated iTunes ID, it will be associated with this ID. If an existing iTunes ID is already associated with this feed it will **NOT** be changed.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyfeedurlGet(url: string, chash: string, itunesid?: number, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new RequiredError('url','Required parameter url was null or undefined when calling addbyfeedurlGet.');
            }
            // verify required parameter 'chash' is not null or undefined
            if (chash === null || chash === undefined) {
                throw new RequiredError('chash','Required parameter chash was null or undefined when calling addbyfeedurlGet.');
            }
            const localVarPath = `/add/byfeedurl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (chash !== undefined) {
                localVarQueryParameter['chash'] = chash;
            }

            if (itunesid !== undefined) {
                localVarQueryParameter['itunesid'] = itunesid;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call adds a podcast to the index using its feed url. If a feed already exists, you will get its existing Feed ID returned.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {number} [itunesid] If this parameter is given, and the existing feed has no associated iTunes ID, it will be associated with this ID. If an existing iTunes ID is already associated with this feed it will **NOT** be changed.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyfeedurlPost(url: string, itunesid?: number, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new RequiredError('url','Required parameter url was null or undefined when calling addbyfeedurlPost.');
            }
            const localVarPath = `/add/byfeedurl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (itunesid !== undefined) {
                localVarQueryParameter['itunesid'] = itunesid;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call adds a podcast to the index using its iTunes ID. If a feed already exists, it will be noted in the response.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} [id] The iTunes ID to add
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyitunesidGet(id?: number, pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/add/byitunesid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call adds a podcast to the index using its iTunes ID. If a feed already exists, it will be noted in the response.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} [id] The iTunes ID to add
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyitunesidPost(id?: number, pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/add/byitunesid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddApi - functional programming interface
 * @export
 */
export const AddApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This call adds a podcast to the index using its feed url. If a feed already exists, you will get its existing Feed ID returned.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {string} chash The md5 hash of the following feed items in hex format. If known, allows for easier duplicate checking.    - &#x60;title&#x60;   - &#x60;link&#x60;   - &#x60;feedLanguage&#x60;   - &#x60;generator&#x60;   - &#x60;author&#x60;   - &#x60;ownerName&#x60;   - &#x60;ownerEmail&#x60; (note: not exposed via the API)  Pseudo-code:        chash &#x3D; md5(title+link+feedLanguage+generator+author+ownerName+ownerEmail)
         * @param {number} [itunesid] If this parameter is given, and the existing feed has no associated iTunes ID, it will be associated with this ID. If an existing iTunes ID is already associated with this feed it will **NOT** be changed.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyfeedurlGet(url: string, chash: string, itunesid?: number, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = AddApiFetchParamCreator(configuration).addbyfeedurlGet(url, chash, itunesid, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call adds a podcast to the index using its feed url. If a feed already exists, you will get its existing Feed ID returned.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {number} [itunesid] If this parameter is given, and the existing feed has no associated iTunes ID, it will be associated with this ID. If an existing iTunes ID is already associated with this feed it will **NOT** be changed.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyfeedurlPost(url: string, itunesid?: number, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = AddApiFetchParamCreator(configuration).addbyfeedurlPost(url, itunesid, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call adds a podcast to the index using its iTunes ID. If a feed already exists, it will be noted in the response.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} [id] The iTunes ID to add
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyitunesidGet(id?: number, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20021> {
            const localVarFetchArgs = AddApiFetchParamCreator(configuration).addbyitunesidGet(id, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call adds a podcast to the index using its iTunes ID. If a feed already exists, it will be noted in the response.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} [id] The iTunes ID to add
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyitunesidPost(id?: number, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20021> {
            const localVarFetchArgs = AddApiFetchParamCreator(configuration).addbyitunesidPost(id, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AddApi - factory interface
 * @export
 */
export const AddApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This call adds a podcast to the index using its feed url. If a feed already exists, you will get its existing Feed ID returned.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {string} chash The md5 hash of the following feed items in hex format. If known, allows for easier duplicate checking.    - &#x60;title&#x60;   - &#x60;link&#x60;   - &#x60;feedLanguage&#x60;   - &#x60;generator&#x60;   - &#x60;author&#x60;   - &#x60;ownerName&#x60;   - &#x60;ownerEmail&#x60; (note: not exposed via the API)  Pseudo-code:        chash &#x3D; md5(title+link+feedLanguage+generator+author+ownerName+ownerEmail)
         * @param {number} [itunesid] If this parameter is given, and the existing feed has no associated iTunes ID, it will be associated with this ID. If an existing iTunes ID is already associated with this feed it will **NOT** be changed.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyfeedurlGet(url: string, chash: string, itunesid?: number, pretty?: boolean, options?: any) {
            return AddApiFp(configuration).addbyfeedurlGet(url, chash, itunesid, pretty, options)(fetch, basePath);
        },
        /**
         * This call adds a podcast to the index using its feed url. If a feed already exists, you will get its existing Feed ID returned.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {number} [itunesid] If this parameter is given, and the existing feed has no associated iTunes ID, it will be associated with this ID. If an existing iTunes ID is already associated with this feed it will **NOT** be changed.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyfeedurlPost(url: string, itunesid?: number, pretty?: boolean, options?: any) {
            return AddApiFp(configuration).addbyfeedurlPost(url, itunesid, pretty, options)(fetch, basePath);
        },
        /**
         * This call adds a podcast to the index using its iTunes ID. If a feed already exists, it will be noted in the response.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} [id] The iTunes ID to add
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyitunesidGet(id?: number, pretty?: boolean, options?: any) {
            return AddApiFp(configuration).addbyitunesidGet(id, pretty, options)(fetch, basePath);
        },
        /**
         * This call adds a podcast to the index using its iTunes ID. If a feed already exists, it will be noted in the response.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} [id] The iTunes ID to add
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addbyitunesidPost(id?: number, pretty?: boolean, options?: any) {
            return AddApiFp(configuration).addbyitunesidPost(id, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * AddApi - object-oriented interface
 * @export
 * @class AddApi
 * @extends {BaseAPI}
 */
export class AddApi extends BaseAPI {
    /**
     * This call adds a podcast to the index using its feed url. If a feed already exists, you will get its existing Feed ID returned.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty
     * @summary By Feed URL
     * @param {string} url Podcast feed URL
     * @param {string} chash The md5 hash of the following feed items in hex format. If known, allows for easier duplicate checking.    - &#x60;title&#x60;   - &#x60;link&#x60;   - &#x60;feedLanguage&#x60;   - &#x60;generator&#x60;   - &#x60;author&#x60;   - &#x60;ownerName&#x60;   - &#x60;ownerEmail&#x60; (note: not exposed via the API)  Pseudo-code:        chash &#x3D; md5(title+link+feedLanguage+generator+author+ownerName+ownerEmail)
     * @param {number} [itunesid] If this parameter is given, and the existing feed has no associated iTunes ID, it will be associated with this ID. If an existing iTunes ID is already associated with this feed it will **NOT** be changed.
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddApi
     */
    public addbyfeedurlGet(url: string, chash: string, itunesid?: number, pretty?: boolean, options?: any) {
        return AddApiFp(this.configuration).addbyfeedurlGet(url, chash, itunesid, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call adds a podcast to the index using its feed url. If a feed already exists, you will get its existing Feed ID returned.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty
     * @summary By Feed URL
     * @param {string} url Podcast feed URL
     * @param {number} [itunesid] If this parameter is given, and the existing feed has no associated iTunes ID, it will be associated with this ID. If an existing iTunes ID is already associated with this feed it will **NOT** be changed.
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddApi
     */
    public addbyfeedurlPost(url: string, itunesid?: number, pretty?: boolean, options?: any) {
        return AddApiFp(this.configuration).addbyfeedurlPost(url, itunesid, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call adds a podcast to the index using its iTunes ID. If a feed already exists, it will be noted in the response.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byitunesid?id=1441923632&pretty
     * @summary By iTunes ID
     * @param {number} [id] The iTunes ID to add
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddApi
     */
    public addbyitunesidGet(id?: number, pretty?: boolean, options?: any) {
        return AddApiFp(this.configuration).addbyitunesidGet(id, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call adds a podcast to the index using its iTunes ID. If a feed already exists, it will be noted in the response.  **NOTE**: this endpoint requires an API Key with the **write** permission.  Example: https://api.podcastindex.org/api/1.0/add/byitunesid?id=1441923632&pretty
     * @summary By iTunes ID
     * @param {number} [id] The iTunes ID to add
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddApi
     */
    public addbyitunesidPost(id?: number, pretty?: boolean, options?: any) {
        return AddApiFp(this.configuration).addbyitunesidPost(id, pretty, options)(this.fetch, this.basePath);
    }

}

export class EpisodesApiApi extends RESTDataSource {
    constructor(baseUrl?: string) {
        super();
        this.baseURL = baseUrl;
    }
    paramCreator = EpisodesApiFetchParamCreator()
    episodesbyfeedid(id: string, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, ): Promise<InlineResponse2008> {
        const args = this.paramCreator.episodesbyfeedid(id, since, max, fulltext, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    episodesbyfeedurl(url: string, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, ): Promise<InlineResponse2009> {
        const args = this.paramCreator.episodesbyfeedurl(url, since, max, fulltext, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    episodesbyid(id: number, fulltext?: boolean, pretty?: boolean, ): Promise<InlineResponse20011> {
        const args = this.paramCreator.episodesbyid(id, fulltext, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    episodesbyitunesid(id: number, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, ): Promise<InlineResponse20010> {
        const args = this.paramCreator.episodesbyitunesid(id, since, max, fulltext, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    episodesrandom(max?: number, lang?: string, cat?: string, notcat?: string, fulltext?: boolean, pretty?: boolean, ): Promise<InlineResponse20012> {
        const args = this.paramCreator.episodesrandom(max, lang, cat, notcat, fulltext, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
}


/**
 * EpisodesApi - fetch parameter creator
 * @export
 */
export const EpisodesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This call returns all the episodes we know about for this feed from the PodcastIndex ID. Episodes are in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=75075&pretty   - https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=41504,920666&pretty   - Includes `persons`: https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=169991&pretty
         * @summary By Feed ID
         * @param {string} id The PodcastIndex Feed ID or IDs to search for.  If searching for multiple IDs, separate values with a comma. A maximum of 200 IDs can be provided.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {number} [max] Maximum number of results to return.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyfeedid(id: string, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling episodesbyfeedid.');
            }
            const localVarPath = `/episodes/byfeedid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (fulltext !== undefined) {
                localVarQueryParameter['fulltext'] = fulltext;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns all the episodes we know about for this feed from the feed URL. Episodes are in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty   - Includes `persons`: https://api.podcastindex.org/api/1.0/episodes/byfeedurl?url=https://engineered.network/pragmatic/feed/index.xml&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {number} [max] Maximum number of results to return.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyfeedurl(url: string, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new RequiredError('url','Required parameter url was null or undefined when calling episodesbyfeedurl.');
            }
            const localVarPath = `/episodes/byfeedurl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (fulltext !== undefined) {
                localVarQueryParameter['fulltext'] = fulltext;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the metadata for a single episode by passing its id.  Example: https://api.podcastindex.org/api/1.0/episodes/byid?id=16795090&pretty
         * @summary By ID
         * @param {number} id The PodcastIndex episode ID to search for.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyid(id: number, fulltext?: boolean, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling episodesbyid.');
            }
            const localVarPath = `/episodes/byid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (fulltext !== undefined) {
                localVarQueryParameter['fulltext'] = fulltext;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns all the episodes we know about for this feed from the iTunes ID. Episodes are in reverse chronological order.  Example: https://api.podcastindex.org/api/1.0/episodes/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} id The iTunes Feed ID to search for
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {number} [max] Maximum number of results to return.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyitunesid(id: number, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling episodesbyitunesid.');
            }
            const localVarPath = `/episodes/byitunesid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (fulltext !== undefined) {
                localVarQueryParameter['fulltext'] = fulltext;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns a random batch of episodes, in no specific order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/random?notcat=News,Religion&lang=en,es&pretty   - https://api.podcastindex.org/api/1.0/episodes/random?max=2&pretty
         * @summary Random
         * @param {number} [max] Maximum number of results to return.
         * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
         * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesrandom(max?: number, lang?: string, cat?: string, notcat?: string, fulltext?: boolean, pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/episodes/random`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (cat !== undefined) {
                localVarQueryParameter['cat'] = cat;
            }

            if (notcat !== undefined) {
                localVarQueryParameter['notcat'] = notcat;
            }

            if (fulltext !== undefined) {
                localVarQueryParameter['fulltext'] = fulltext;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EpisodesApi - functional programming interface
 * @export
 */
export const EpisodesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This call returns all the episodes we know about for this feed from the PodcastIndex ID. Episodes are in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=75075&pretty   - https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=41504,920666&pretty   - Includes `persons`: https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=169991&pretty
         * @summary By Feed ID
         * @param {string} id The PodcastIndex Feed ID or IDs to search for.  If searching for multiple IDs, separate values with a comma. A maximum of 200 IDs can be provided.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {number} [max] Maximum number of results to return.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyfeedid(id: string, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = EpisodesApiFetchParamCreator(configuration).episodesbyfeedid(id, since, max, fulltext, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns all the episodes we know about for this feed from the feed URL. Episodes are in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty   - Includes `persons`: https://api.podcastindex.org/api/1.0/episodes/byfeedurl?url=https://engineered.network/pragmatic/feed/index.xml&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {number} [max] Maximum number of results to return.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyfeedurl(url: string, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = EpisodesApiFetchParamCreator(configuration).episodesbyfeedurl(url, since, max, fulltext, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all the metadata for a single episode by passing its id.  Example: https://api.podcastindex.org/api/1.0/episodes/byid?id=16795090&pretty
         * @summary By ID
         * @param {number} id The PodcastIndex episode ID to search for.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyid(id: number, fulltext?: boolean, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = EpisodesApiFetchParamCreator(configuration).episodesbyid(id, fulltext, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns all the episodes we know about for this feed from the iTunes ID. Episodes are in reverse chronological order.  Example: https://api.podcastindex.org/api/1.0/episodes/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} id The iTunes Feed ID to search for
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {number} [max] Maximum number of results to return.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyitunesid(id: number, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = EpisodesApiFetchParamCreator(configuration).episodesbyitunesid(id, since, max, fulltext, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns a random batch of episodes, in no specific order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/random?notcat=News,Religion&lang=en,es&pretty   - https://api.podcastindex.org/api/1.0/episodes/random?max=2&pretty
         * @summary Random
         * @param {number} [max] Maximum number of results to return.
         * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
         * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesrandom(max?: number, lang?: string, cat?: string, notcat?: string, fulltext?: boolean, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = EpisodesApiFetchParamCreator(configuration).episodesrandom(max, lang, cat, notcat, fulltext, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EpisodesApi - factory interface
 * @export
 */
export const EpisodesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This call returns all the episodes we know about for this feed from the PodcastIndex ID. Episodes are in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=75075&pretty   - https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=41504,920666&pretty   - Includes `persons`: https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=169991&pretty
         * @summary By Feed ID
         * @param {string} id The PodcastIndex Feed ID or IDs to search for.  If searching for multiple IDs, separate values with a comma. A maximum of 200 IDs can be provided.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {number} [max] Maximum number of results to return.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyfeedid(id: string, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options?: any) {
            return EpisodesApiFp(configuration).episodesbyfeedid(id, since, max, fulltext, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns all the episodes we know about for this feed from the feed URL. Episodes are in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty   - Includes `persons`: https://api.podcastindex.org/api/1.0/episodes/byfeedurl?url=https://engineered.network/pragmatic/feed/index.xml&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {number} [max] Maximum number of results to return.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyfeedurl(url: string, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options?: any) {
            return EpisodesApiFp(configuration).episodesbyfeedurl(url, since, max, fulltext, pretty, options)(fetch, basePath);
        },
        /**
         * Get all the metadata for a single episode by passing its id.  Example: https://api.podcastindex.org/api/1.0/episodes/byid?id=16795090&pretty
         * @summary By ID
         * @param {number} id The PodcastIndex episode ID to search for.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyid(id: number, fulltext?: boolean, pretty?: boolean, options?: any) {
            return EpisodesApiFp(configuration).episodesbyid(id, fulltext, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns all the episodes we know about for this feed from the iTunes ID. Episodes are in reverse chronological order.  Example: https://api.podcastindex.org/api/1.0/episodes/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} id The iTunes Feed ID to search for
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {number} [max] Maximum number of results to return.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesbyitunesid(id: number, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options?: any) {
            return EpisodesApiFp(configuration).episodesbyitunesid(id, since, max, fulltext, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns a random batch of episodes, in no specific order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/random?notcat=News,Religion&lang=en,es&pretty   - https://api.podcastindex.org/api/1.0/episodes/random?max=2&pretty
         * @summary Random
         * @param {number} [max] Maximum number of results to return.
         * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
         * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        episodesrandom(max?: number, lang?: string, cat?: string, notcat?: string, fulltext?: boolean, pretty?: boolean, options?: any) {
            return EpisodesApiFp(configuration).episodesrandom(max, lang, cat, notcat, fulltext, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * EpisodesApi - object-oriented interface
 * @export
 * @class EpisodesApi
 * @extends {BaseAPI}
 */
export class EpisodesApi extends BaseAPI {
    /**
     * This call returns all the episodes we know about for this feed from the PodcastIndex ID. Episodes are in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=75075&pretty   - https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=41504,920666&pretty   - Includes `persons`: https://api.podcastindex.org/api/1.0/episodes/byfeedid?id=169991&pretty
     * @summary By Feed ID
     * @param {string} id The PodcastIndex Feed ID or IDs to search for.  If searching for multiple IDs, separate values with a comma. A maximum of 200 IDs can be provided.
     * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
     * @param {number} [max] Maximum number of results to return.
     * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EpisodesApi
     */
    public episodesbyfeedid(id: string, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options?: any) {
        return EpisodesApiFp(this.configuration).episodesbyfeedid(id, since, max, fulltext, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns all the episodes we know about for this feed from the feed URL. Episodes are in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty   - Includes `persons`: https://api.podcastindex.org/api/1.0/episodes/byfeedurl?url=https://engineered.network/pragmatic/feed/index.xml&pretty
     * @summary By Feed URL
     * @param {string} url Podcast feed URL
     * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
     * @param {number} [max] Maximum number of results to return.
     * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EpisodesApi
     */
    public episodesbyfeedurl(url: string, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options?: any) {
        return EpisodesApiFp(this.configuration).episodesbyfeedurl(url, since, max, fulltext, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * Get all the metadata for a single episode by passing its id.  Example: https://api.podcastindex.org/api/1.0/episodes/byid?id=16795090&pretty
     * @summary By ID
     * @param {number} id The PodcastIndex episode ID to search for.
     * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EpisodesApi
     */
    public episodesbyid(id: number, fulltext?: boolean, pretty?: boolean, options?: any) {
        return EpisodesApiFp(this.configuration).episodesbyid(id, fulltext, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns all the episodes we know about for this feed from the iTunes ID. Episodes are in reverse chronological order.  Example: https://api.podcastindex.org/api/1.0/episodes/byitunesid?id=1441923632&pretty
     * @summary By iTunes ID
     * @param {number} id The iTunes Feed ID to search for
     * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
     * @param {number} [max] Maximum number of results to return.
     * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EpisodesApi
     */
    public episodesbyitunesid(id: number, since?: number, max?: number, fulltext?: boolean, pretty?: boolean, options?: any) {
        return EpisodesApiFp(this.configuration).episodesbyitunesid(id, since, max, fulltext, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns a random batch of episodes, in no specific order.  Examples:    - https://api.podcastindex.org/api/1.0/episodes/random?notcat=News,Religion&lang=en,es&pretty   - https://api.podcastindex.org/api/1.0/episodes/random?max=2&pretty
     * @summary Random
     * @param {number} [max] Maximum number of results to return.
     * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
     * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
     * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
     * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EpisodesApi
     */
    public episodesrandom(max?: number, lang?: string, cat?: string, notcat?: string, fulltext?: boolean, pretty?: boolean, options?: any) {
        return EpisodesApiFp(this.configuration).episodesrandom(max, lang, cat, notcat, fulltext, pretty, options)(this.fetch, this.basePath);
    }

}

export class PodcastsApiApi extends RESTDataSource {
    constructor(baseUrl?: string) {
        super();
        this.baseURL = baseUrl;
    }
    paramCreator = PodcastsApiFetchParamCreator()
    podcastsbyfeedid(id: number, pretty?: boolean, ): Promise<InlineResponse2002> {
        const args = this.paramCreator.podcastsbyfeedid(id, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    podcastsbyfeedurl(url: string, pretty?: boolean, ): Promise<InlineResponse2003> {
        const args = this.paramCreator.podcastsbyfeedurl(url, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    podcastsbyitunesid(id: number, pretty?: boolean, ): Promise<InlineResponse2004> {
        const args = this.paramCreator.podcastsbyitunesid(id, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    podcastsbytag(podcastValue: boolean, pretty?: boolean, ): Promise<InlineResponse2005> {
        const args = this.paramCreator.podcastsbytag(podcastValue, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    podcastsdead(pretty?: boolean, ): Promise<InlineResponse2007> {
        const args = this.paramCreator.podcastsdead(pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    podcaststrending(max?: number, since?: number, lang?: string, cat?: string, notcat?: string, pretty?: boolean, ): Promise<InlineResponse2006> {
        const args = this.paramCreator.podcaststrending(max, since, lang, cat, notcat, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
}


/**
 * PodcastsApi - fetch parameter creator
 * @export
 */
export const PodcastsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This call returns everything we know about the feed from the PodcastIndex ID  Examples:    - https://api.podcastindex.org/api/1.0/podcasts/byfeedid?id=75075&pretty   - Includes `value` and `funding`: https://api.podcastindex.org/api/1.0/podcasts/byfeedid?id=169991&pretty
         * @summary By Feed ID
         * @param {number} id The PodcastIndex Feed ID to search for
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbyfeedid(id: number, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling podcastsbyfeedid.');
            }
            const localVarPath = `/podcasts/byfeedid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns everything we know about the feed from the feed URL  Examples:    - https://api.podcastindex.org/api/1.0/podcasts/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty   - Includes `value` and `funding`: https://api.podcastindex.org/api/1.0/podcasts/byfeedurl?url=https://engineered.network/pragmatic/feed/index.xml&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbyfeedurl(url: string, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new RequiredError('url','Required parameter url was null or undefined when calling podcastsbyfeedurl.');
            }
            const localVarPath = `/podcasts/byfeedurl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns everything we know about the feed from the iTunes ID  Example: https://api.podcastindex.org/api/1.0/podcasts/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} id The iTunes Feed ID to search for
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbyitunesid(id: number, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling podcastsbyitunesid.');
            }
            const localVarPath = `/podcasts/byitunesid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns all feeds that support the specified [podcast namespace](https://podcastindex.org/namespace/1.0) tag.  Example: https://api.podcastindex.org/api/1.0/podcasts/bytag?podcast-value&pretty
         * @summary By Tag
         * @param {boolean} podcastValue Get feeds supporting the &#x60;value&#x60; tag.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbytag(podcastValue: boolean, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'podcastValue' is not null or undefined
            if (podcastValue === null || podcastValue === undefined) {
                throw new RequiredError('podcastValue','Required parameter podcastValue was null or undefined when calling podcastsbytag.');
            }
            const localVarPath = `/podcasts/bytag`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (podcastValue !== undefined) {
                localVarQueryParameter['podcast-value'] = podcastValue;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns all feeds that have been marked dead (`dead` == 1)  Example: https://api.podcastindex.org/api/1.0/podcasts/dead?pretty
         * @summary Dead
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsdead(pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/podcasts/dead`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns the podcasts/feeds that in the index that are trending.  Example: https://api.podcastindex.org/api/1.0/podcasts/trending?pretty
         * @summary Trending
         * @param {number} [max] Maximum number of results to return.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
         * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcaststrending(max?: number, since?: number, lang?: string, cat?: string, notcat?: string, pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/podcasts/trending`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (cat !== undefined) {
                localVarQueryParameter['cat'] = cat;
            }

            if (notcat !== undefined) {
                localVarQueryParameter['notcat'] = notcat;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PodcastsApi - functional programming interface
 * @export
 */
export const PodcastsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This call returns everything we know about the feed from the PodcastIndex ID  Examples:    - https://api.podcastindex.org/api/1.0/podcasts/byfeedid?id=75075&pretty   - Includes `value` and `funding`: https://api.podcastindex.org/api/1.0/podcasts/byfeedid?id=169991&pretty
         * @summary By Feed ID
         * @param {number} id The PodcastIndex Feed ID to search for
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbyfeedid(id: number, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = PodcastsApiFetchParamCreator(configuration).podcastsbyfeedid(id, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns everything we know about the feed from the feed URL  Examples:    - https://api.podcastindex.org/api/1.0/podcasts/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty   - Includes `value` and `funding`: https://api.podcastindex.org/api/1.0/podcasts/byfeedurl?url=https://engineered.network/pragmatic/feed/index.xml&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbyfeedurl(url: string, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = PodcastsApiFetchParamCreator(configuration).podcastsbyfeedurl(url, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns everything we know about the feed from the iTunes ID  Example: https://api.podcastindex.org/api/1.0/podcasts/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} id The iTunes Feed ID to search for
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbyitunesid(id: number, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = PodcastsApiFetchParamCreator(configuration).podcastsbyitunesid(id, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns all feeds that support the specified [podcast namespace](https://podcastindex.org/namespace/1.0) tag.  Example: https://api.podcastindex.org/api/1.0/podcasts/bytag?podcast-value&pretty
         * @summary By Tag
         * @param {boolean} podcastValue Get feeds supporting the &#x60;value&#x60; tag.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbytag(podcastValue: boolean, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = PodcastsApiFetchParamCreator(configuration).podcastsbytag(podcastValue, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns all feeds that have been marked dead (`dead` == 1)  Example: https://api.podcastindex.org/api/1.0/podcasts/dead?pretty
         * @summary Dead
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsdead(pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = PodcastsApiFetchParamCreator(configuration).podcastsdead(pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns the podcasts/feeds that in the index that are trending.  Example: https://api.podcastindex.org/api/1.0/podcasts/trending?pretty
         * @summary Trending
         * @param {number} [max] Maximum number of results to return.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
         * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcaststrending(max?: number, since?: number, lang?: string, cat?: string, notcat?: string, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = PodcastsApiFetchParamCreator(configuration).podcaststrending(max, since, lang, cat, notcat, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PodcastsApi - factory interface
 * @export
 */
export const PodcastsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This call returns everything we know about the feed from the PodcastIndex ID  Examples:    - https://api.podcastindex.org/api/1.0/podcasts/byfeedid?id=75075&pretty   - Includes `value` and `funding`: https://api.podcastindex.org/api/1.0/podcasts/byfeedid?id=169991&pretty
         * @summary By Feed ID
         * @param {number} id The PodcastIndex Feed ID to search for
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbyfeedid(id: number, pretty?: boolean, options?: any) {
            return PodcastsApiFp(configuration).podcastsbyfeedid(id, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns everything we know about the feed from the feed URL  Examples:    - https://api.podcastindex.org/api/1.0/podcasts/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty   - Includes `value` and `funding`: https://api.podcastindex.org/api/1.0/podcasts/byfeedurl?url=https://engineered.network/pragmatic/feed/index.xml&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbyfeedurl(url: string, pretty?: boolean, options?: any) {
            return PodcastsApiFp(configuration).podcastsbyfeedurl(url, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns everything we know about the feed from the iTunes ID  Example: https://api.podcastindex.org/api/1.0/podcasts/byitunesid?id=1441923632&pretty
         * @summary By iTunes ID
         * @param {number} id The iTunes Feed ID to search for
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbyitunesid(id: number, pretty?: boolean, options?: any) {
            return PodcastsApiFp(configuration).podcastsbyitunesid(id, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns all feeds that support the specified [podcast namespace](https://podcastindex.org/namespace/1.0) tag.  Example: https://api.podcastindex.org/api/1.0/podcasts/bytag?podcast-value&pretty
         * @summary By Tag
         * @param {boolean} podcastValue Get feeds supporting the &#x60;value&#x60; tag.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsbytag(podcastValue: boolean, pretty?: boolean, options?: any) {
            return PodcastsApiFp(configuration).podcastsbytag(podcastValue, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns all feeds that have been marked dead (`dead` == 1)  Example: https://api.podcastindex.org/api/1.0/podcasts/dead?pretty
         * @summary Dead
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsdead(pretty?: boolean, options?: any) {
            return PodcastsApiFp(configuration).podcastsdead(pretty, options)(fetch, basePath);
        },
        /**
         * This call returns the podcasts/feeds that in the index that are trending.  Example: https://api.podcastindex.org/api/1.0/podcasts/trending?pretty
         * @summary Trending
         * @param {number} [max] Maximum number of results to return.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
         * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcaststrending(max?: number, since?: number, lang?: string, cat?: string, notcat?: string, pretty?: boolean, options?: any) {
            return PodcastsApiFp(configuration).podcaststrending(max, since, lang, cat, notcat, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * PodcastsApi - object-oriented interface
 * @export
 * @class PodcastsApi
 * @extends {BaseAPI}
 */
export class PodcastsApi extends BaseAPI {
    /**
     * This call returns everything we know about the feed from the PodcastIndex ID  Examples:    - https://api.podcastindex.org/api/1.0/podcasts/byfeedid?id=75075&pretty   - Includes `value` and `funding`: https://api.podcastindex.org/api/1.0/podcasts/byfeedid?id=169991&pretty
     * @summary By Feed ID
     * @param {number} id The PodcastIndex Feed ID to search for
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcastsbyfeedid(id: number, pretty?: boolean, options?: any) {
        return PodcastsApiFp(this.configuration).podcastsbyfeedid(id, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns everything we know about the feed from the feed URL  Examples:    - https://api.podcastindex.org/api/1.0/podcasts/byfeedurl?url=https://feeds.theincomparable.com/batmanuniversity&pretty   - Includes `value` and `funding`: https://api.podcastindex.org/api/1.0/podcasts/byfeedurl?url=https://engineered.network/pragmatic/feed/index.xml&pretty
     * @summary By Feed URL
     * @param {string} url Podcast feed URL
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcastsbyfeedurl(url: string, pretty?: boolean, options?: any) {
        return PodcastsApiFp(this.configuration).podcastsbyfeedurl(url, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns everything we know about the feed from the iTunes ID  Example: https://api.podcastindex.org/api/1.0/podcasts/byitunesid?id=1441923632&pretty
     * @summary By iTunes ID
     * @param {number} id The iTunes Feed ID to search for
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcastsbyitunesid(id: number, pretty?: boolean, options?: any) {
        return PodcastsApiFp(this.configuration).podcastsbyitunesid(id, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns all feeds that support the specified [podcast namespace](https://podcastindex.org/namespace/1.0) tag.  Example: https://api.podcastindex.org/api/1.0/podcasts/bytag?podcast-value&pretty
     * @summary By Tag
     * @param {boolean} podcastValue Get feeds supporting the &#x60;value&#x60; tag.  Parameter shall not have a value
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcastsbytag(podcastValue: boolean, pretty?: boolean, options?: any) {
        return PodcastsApiFp(this.configuration).podcastsbytag(podcastValue, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns all feeds that have been marked dead (`dead` == 1)  Example: https://api.podcastindex.org/api/1.0/podcasts/dead?pretty
     * @summary Dead
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcastsdead(pretty?: boolean, options?: any) {
        return PodcastsApiFp(this.configuration).podcastsdead(pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns the podcasts/feeds that in the index that are trending.  Example: https://api.podcastindex.org/api/1.0/podcasts/trending?pretty
     * @summary Trending
     * @param {number} [max] Maximum number of results to return.
     * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
     * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
     * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
     * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcaststrending(max?: number, since?: number, lang?: string, cat?: string, notcat?: string, pretty?: boolean, options?: any) {
        return PodcastsApiFp(this.configuration).podcaststrending(max, since, lang, cat, notcat, pretty, options)(this.fetch, this.basePath);
    }

}

export class RecentApiApi extends RESTDataSource {
    constructor(baseUrl?: string) {
        super();
        this.baseURL = baseUrl;
    }
    paramCreator = RecentApiFetchParamCreator()
    recentepisodes(max?: number, excludeString?: string, before?: number, fulltext?: boolean, pretty?: boolean, ): Promise<InlineResponse20013> {
        const args = this.paramCreator.recentepisodes(max, excludeString, before, fulltext, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    recentfeeds(max?: number, since?: number, lang?: string, cat?: string, notcat?: string, pretty?: boolean, ): Promise<InlineResponse20014> {
        const args = this.paramCreator.recentfeeds(max, since, lang, cat, notcat, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    recentnewfeeds(max?: number, since?: number, pretty?: boolean, ): Promise<InlineResponse20015> {
        const args = this.paramCreator.recentnewfeeds(max, since, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    recentsoundbites(max?: number, pretty?: boolean, ): Promise<InlineResponse20016> {
        const args = this.paramCreator.recentsoundbites(max, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
}


/**
 * RecentApi - fetch parameter creator
 * @export
 */
export const RecentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This call returns the most recent `max` number of episodes globally across the whole index, in reverse chronological order.  Example: https://api.podcastindex.org/api/1.0/recent/episodes?max=7&pretty
         * @summary Episodes
         * @param {number} [max] Maximum number of results to return.
         * @param {string} [excludeString] Any item containing this string will be discarded from the result set.  This may, in certain cases, reduce your set size below your &#x60;max&#x60; value.  Matches against the &#x60;title&#x60; and URL properties.
         * @param {number} [before] If you pass a PodcastIndex Episode ID, you will get recent episodes before that ID, allowing you to walk back through the episode history sequentially.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentepisodes(max?: number, excludeString?: string, before?: number, fulltext?: boolean, pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/recent/episodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (excludeString !== undefined) {
                localVarQueryParameter['excludeString'] = excludeString;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (fulltext !== undefined) {
                localVarQueryParameter['fulltext'] = fulltext;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns the most recent `max` feeds, in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/recent/feeds?pretty   - https://api.podcastindex.org/api/1.0/recent/feeds?max=20&cat=102,health&lang=de,ja&pretty
         * @summary Feeds
         * @param {number} [max] Maximum number of results to return.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
         * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentfeeds(max?: number, since?: number, lang?: string, cat?: string, notcat?: string, pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/recent/feeds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (cat !== undefined) {
                localVarQueryParameter['cat'] = cat;
            }

            if (notcat !== undefined) {
                localVarQueryParameter['notcat'] = notcat;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns every new feed added to the index over the past 24 hours in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/recent/newfeeds?pretty   - https://api.podcastindex.org/api/1.0/recent/newfeeds?pretty&since=1613805000
         * @summary New Feeds
         * @param {number} [max] Maximum number of results to return.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentnewfeeds(max?: number, since?: number, pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/recent/newfeeds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns the most recent `max` soundbites that the index has discovered.  A soundbite consists of an enclosure url, a start time and a duration. It is documented in the [podcast namespace](https://podcastindex.org/namespace/1.0#soundbite).  Example: https://api.podcastindex.org/api/1.0/recent/soundbites?pretty
         * @summary Soundbites
         * @param {number} [max] Maximum number of soundbites to return.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentsoundbites(max?: number, pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/recent/soundbites`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecentApi - functional programming interface
 * @export
 */
export const RecentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This call returns the most recent `max` number of episodes globally across the whole index, in reverse chronological order.  Example: https://api.podcastindex.org/api/1.0/recent/episodes?max=7&pretty
         * @summary Episodes
         * @param {number} [max] Maximum number of results to return.
         * @param {string} [excludeString] Any item containing this string will be discarded from the result set.  This may, in certain cases, reduce your set size below your &#x60;max&#x60; value.  Matches against the &#x60;title&#x60; and URL properties.
         * @param {number} [before] If you pass a PodcastIndex Episode ID, you will get recent episodes before that ID, allowing you to walk back through the episode history sequentially.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentepisodes(max?: number, excludeString?: string, before?: number, fulltext?: boolean, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = RecentApiFetchParamCreator(configuration).recentepisodes(max, excludeString, before, fulltext, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns the most recent `max` feeds, in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/recent/feeds?pretty   - https://api.podcastindex.org/api/1.0/recent/feeds?max=20&cat=102,health&lang=de,ja&pretty
         * @summary Feeds
         * @param {number} [max] Maximum number of results to return.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
         * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentfeeds(max?: number, since?: number, lang?: string, cat?: string, notcat?: string, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = RecentApiFetchParamCreator(configuration).recentfeeds(max, since, lang, cat, notcat, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns every new feed added to the index over the past 24 hours in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/recent/newfeeds?pretty   - https://api.podcastindex.org/api/1.0/recent/newfeeds?pretty&since=1613805000
         * @summary New Feeds
         * @param {number} [max] Maximum number of results to return.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentnewfeeds(max?: number, since?: number, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = RecentApiFetchParamCreator(configuration).recentnewfeeds(max, since, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns the most recent `max` soundbites that the index has discovered.  A soundbite consists of an enclosure url, a start time and a duration. It is documented in the [podcast namespace](https://podcastindex.org/namespace/1.0#soundbite).  Example: https://api.podcastindex.org/api/1.0/recent/soundbites?pretty
         * @summary Soundbites
         * @param {number} [max] Maximum number of soundbites to return.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentsoundbites(max?: number, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = RecentApiFetchParamCreator(configuration).recentsoundbites(max, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RecentApi - factory interface
 * @export
 */
export const RecentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This call returns the most recent `max` number of episodes globally across the whole index, in reverse chronological order.  Example: https://api.podcastindex.org/api/1.0/recent/episodes?max=7&pretty
         * @summary Episodes
         * @param {number} [max] Maximum number of results to return.
         * @param {string} [excludeString] Any item containing this string will be discarded from the result set.  This may, in certain cases, reduce your set size below your &#x60;max&#x60; value.  Matches against the &#x60;title&#x60; and URL properties.
         * @param {number} [before] If you pass a PodcastIndex Episode ID, you will get recent episodes before that ID, allowing you to walk back through the episode history sequentially.
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentepisodes(max?: number, excludeString?: string, before?: number, fulltext?: boolean, pretty?: boolean, options?: any) {
            return RecentApiFp(configuration).recentepisodes(max, excludeString, before, fulltext, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns the most recent `max` feeds, in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/recent/feeds?pretty   - https://api.podcastindex.org/api/1.0/recent/feeds?max=20&cat=102,health&lang=de,ja&pretty
         * @summary Feeds
         * @param {number} [max] Maximum number of results to return.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
         * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentfeeds(max?: number, since?: number, lang?: string, cat?: string, notcat?: string, pretty?: boolean, options?: any) {
            return RecentApiFp(configuration).recentfeeds(max, since, lang, cat, notcat, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns every new feed added to the index over the past 24 hours in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/recent/newfeeds?pretty   - https://api.podcastindex.org/api/1.0/recent/newfeeds?pretty&since=1613805000
         * @summary New Feeds
         * @param {number} [max] Maximum number of results to return.
         * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentnewfeeds(max?: number, since?: number, pretty?: boolean, options?: any) {
            return RecentApiFp(configuration).recentnewfeeds(max, since, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns the most recent `max` soundbites that the index has discovered.  A soundbite consists of an enclosure url, a start time and a duration. It is documented in the [podcast namespace](https://podcastindex.org/namespace/1.0#soundbite).  Example: https://api.podcastindex.org/api/1.0/recent/soundbites?pretty
         * @summary Soundbites
         * @param {number} [max] Maximum number of soundbites to return.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentsoundbites(max?: number, pretty?: boolean, options?: any) {
            return RecentApiFp(configuration).recentsoundbites(max, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * RecentApi - object-oriented interface
 * @export
 * @class RecentApi
 * @extends {BaseAPI}
 */
export class RecentApi extends BaseAPI {
    /**
     * This call returns the most recent `max` number of episodes globally across the whole index, in reverse chronological order.  Example: https://api.podcastindex.org/api/1.0/recent/episodes?max=7&pretty
     * @summary Episodes
     * @param {number} [max] Maximum number of results to return.
     * @param {string} [excludeString] Any item containing this string will be discarded from the result set.  This may, in certain cases, reduce your set size below your &#x60;max&#x60; value.  Matches against the &#x60;title&#x60; and URL properties.
     * @param {number} [before] If you pass a PodcastIndex Episode ID, you will get recent episodes before that ID, allowing you to walk back through the episode history sequentially.
     * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentApi
     */
    public recentepisodes(max?: number, excludeString?: string, before?: number, fulltext?: boolean, pretty?: boolean, options?: any) {
        return RecentApiFp(this.configuration).recentepisodes(max, excludeString, before, fulltext, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns the most recent `max` feeds, in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/recent/feeds?pretty   - https://api.podcastindex.org/api/1.0/recent/feeds?max=20&cat=102,health&lang=de,ja&pretty
     * @summary Feeds
     * @param {number} [max] Maximum number of results to return.
     * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
     * @param {string} [lang] Specifying a language code (like \&quot;en\&quot;) will return only episodes having that specific language.  You can specify multiple languages by separating them with commas.  If you also want to return episodes that have no language given, use the token \&quot;unknown\&quot;. (ex. en,es,ja,unknown).  Values are not case sensitive.
     * @param {string} [cat] Use this argument to specify that you **ONLY** want episodes with these categories in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
     * @param {string} [notcat] Use this argument to specify categories of episodes to **NOT** show in the results.  Separate multiple categories with commas.  You may specify either the Category ID and/or the Category Name.  Values are not case sensitive.  The &#x60;cat&#x60; and &#x60;notcat&#x60; filters can be used together to fine tune a very specific result set.  Category numbers and names can be found in the [Podcast Namespace documentation](https://github.com/Podcastindex-org/podcast-namespace/blob/main/categories.json)
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentApi
     */
    public recentfeeds(max?: number, since?: number, lang?: string, cat?: string, notcat?: string, pretty?: boolean, options?: any) {
        return RecentApiFp(this.configuration).recentfeeds(max, since, lang, cat, notcat, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns every new feed added to the index over the past 24 hours in reverse chronological order.  Examples:    - https://api.podcastindex.org/api/1.0/recent/newfeeds?pretty   - https://api.podcastindex.org/api/1.0/recent/newfeeds?pretty&since=1613805000
     * @summary New Feeds
     * @param {number} [max] Maximum number of results to return.
     * @param {number} [since] Return items since the specified time. The value can be a unix epoch timestamp or a negative integer that represents a number of seconds prior to right now.
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentApi
     */
    public recentnewfeeds(max?: number, since?: number, pretty?: boolean, options?: any) {
        return RecentApiFp(this.configuration).recentnewfeeds(max, since, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns the most recent `max` soundbites that the index has discovered.  A soundbite consists of an enclosure url, a start time and a duration. It is documented in the [podcast namespace](https://podcastindex.org/namespace/1.0#soundbite).  Example: https://api.podcastindex.org/api/1.0/recent/soundbites?pretty
     * @summary Soundbites
     * @param {number} [max] Maximum number of soundbites to return.
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentApi
     */
    public recentsoundbites(max?: number, pretty?: boolean, options?: any) {
        return RecentApiFp(this.configuration).recentsoundbites(max, pretty, options)(this.fetch, this.basePath);
    }

}

export class SearchApiApi extends RESTDataSource {
    constructor(baseUrl?: string) {
        super();
        this.baseURL = baseUrl;
    }
    paramCreator = SearchApiFetchParamCreator()
    searchbyperson(q: string, fulltext?: boolean, pretty?: boolean, ): Promise<InlineResponse2001> {
        const args = this.paramCreator.searchbyperson(q, fulltext, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    searchbyterm(q: string, val?: string, clean?: boolean, fulltext?: boolean, pretty?: boolean, ): Promise<InlineResponse200> {
        const args = this.paramCreator.searchbyterm(q, val, clean, fulltext, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
}


/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This call returns all of the episodes where the specified person is mentioned.  Examples:    - https://api.podcastindex.org/api/1.0/search/byperson?q=adam%20curry&pretty   - https://api.podcastindex.org/api/1.0/search/byperson?q=Martin+Mouritzen&pretty   - https://api.podcastindex.org/api/1.0/search/byperson?q=Klaus+Schwab&pretty
         * @summary Search Episodes by Person
         * @param {string} q Person search for
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchbyperson(q: string, fulltext?: boolean, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling searchbyperson.');
            }
            const localVarPath = `/search/byperson`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (fulltext !== undefined) {
                localVarQueryParameter['fulltext'] = fulltext;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns all of the feeds that match the search terms in the `title`, `author` or `owner` of the feed.  This is ordered by the last-released episode, with the latest at the top of the results.  Example: https://api.podcastindex.org/api/1.0/search/byterm?q=batman+university&pretty
         * @summary Search Podcasts
         * @param {string} q Terms to search for
         * @param {string} [val] Only returns feeds with a &#x60;value&#x60; block of the specified type. Use &#x60;any&#x60; to return feeds with any &#x60;value&#x60; block.
         * @param {boolean} [clean] If present, only non-explicit feeds will be returned. Meaning, feeds where the &#x60;itunes:explicit&#x60; flag is set to &#x60;false&#x60;.  Parameter shall not have a value
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchbyterm(q: string, val?: string, clean?: boolean, fulltext?: boolean, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling searchbyterm.');
            }
            const localVarPath = `/search/byterm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (val !== undefined) {
                localVarQueryParameter['val'] = val;
            }

            if (clean !== undefined) {
                localVarQueryParameter['clean'] = clean;
            }

            if (fulltext !== undefined) {
                localVarQueryParameter['fulltext'] = fulltext;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This call returns all of the episodes where the specified person is mentioned.  Examples:    - https://api.podcastindex.org/api/1.0/search/byperson?q=adam%20curry&pretty   - https://api.podcastindex.org/api/1.0/search/byperson?q=Martin+Mouritzen&pretty   - https://api.podcastindex.org/api/1.0/search/byperson?q=Klaus+Schwab&pretty
         * @summary Search Episodes by Person
         * @param {string} q Person search for
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchbyperson(q: string, fulltext?: boolean, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).searchbyperson(q, fulltext, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns all of the feeds that match the search terms in the `title`, `author` or `owner` of the feed.  This is ordered by the last-released episode, with the latest at the top of the results.  Example: https://api.podcastindex.org/api/1.0/search/byterm?q=batman+university&pretty
         * @summary Search Podcasts
         * @param {string} q Terms to search for
         * @param {string} [val] Only returns feeds with a &#x60;value&#x60; block of the specified type. Use &#x60;any&#x60; to return feeds with any &#x60;value&#x60; block.
         * @param {boolean} [clean] If present, only non-explicit feeds will be returned. Meaning, feeds where the &#x60;itunes:explicit&#x60; flag is set to &#x60;false&#x60;.  Parameter shall not have a value
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchbyterm(q: string, val?: string, clean?: boolean, fulltext?: boolean, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).searchbyterm(q, val, clean, fulltext, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This call returns all of the episodes where the specified person is mentioned.  Examples:    - https://api.podcastindex.org/api/1.0/search/byperson?q=adam%20curry&pretty   - https://api.podcastindex.org/api/1.0/search/byperson?q=Martin+Mouritzen&pretty   - https://api.podcastindex.org/api/1.0/search/byperson?q=Klaus+Schwab&pretty
         * @summary Search Episodes by Person
         * @param {string} q Person search for
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchbyperson(q: string, fulltext?: boolean, pretty?: boolean, options?: any) {
            return SearchApiFp(configuration).searchbyperson(q, fulltext, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns all of the feeds that match the search terms in the `title`, `author` or `owner` of the feed.  This is ordered by the last-released episode, with the latest at the top of the results.  Example: https://api.podcastindex.org/api/1.0/search/byterm?q=batman+university&pretty
         * @summary Search Podcasts
         * @param {string} q Terms to search for
         * @param {string} [val] Only returns feeds with a &#x60;value&#x60; block of the specified type. Use &#x60;any&#x60; to return feeds with any &#x60;value&#x60; block.
         * @param {boolean} [clean] If present, only non-explicit feeds will be returned. Meaning, feeds where the &#x60;itunes:explicit&#x60; flag is set to &#x60;false&#x60;.  Parameter shall not have a value
         * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchbyterm(q: string, val?: string, clean?: boolean, fulltext?: boolean, pretty?: boolean, options?: any) {
            return SearchApiFp(configuration).searchbyterm(q, val, clean, fulltext, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * This call returns all of the episodes where the specified person is mentioned.  Examples:    - https://api.podcastindex.org/api/1.0/search/byperson?q=adam%20curry&pretty   - https://api.podcastindex.org/api/1.0/search/byperson?q=Martin+Mouritzen&pretty   - https://api.podcastindex.org/api/1.0/search/byperson?q=Klaus+Schwab&pretty
     * @summary Search Episodes by Person
     * @param {string} q Person search for
     * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchbyperson(q: string, fulltext?: boolean, pretty?: boolean, options?: any) {
        return SearchApiFp(this.configuration).searchbyperson(q, fulltext, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns all of the feeds that match the search terms in the `title`, `author` or `owner` of the feed.  This is ordered by the last-released episode, with the latest at the top of the results.  Example: https://api.podcastindex.org/api/1.0/search/byterm?q=batman+university&pretty
     * @summary Search Podcasts
     * @param {string} q Terms to search for
     * @param {string} [val] Only returns feeds with a &#x60;value&#x60; block of the specified type. Use &#x60;any&#x60; to return feeds with any &#x60;value&#x60; block.
     * @param {boolean} [clean] If present, only non-explicit feeds will be returned. Meaning, feeds where the &#x60;itunes:explicit&#x60; flag is set to &#x60;false&#x60;.  Parameter shall not have a value
     * @param {boolean} [fulltext] If present, return the full text value of any text fields (ex: &#x60;description&#x60;). If not provided, field value is truncated to 100 words.  Parameter shall not have a value
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchbyterm(q: string, val?: string, clean?: boolean, fulltext?: boolean, pretty?: boolean, options?: any) {
        return SearchApiFp(this.configuration).searchbyterm(q, val, clean, fulltext, pretty, options)(this.fetch, this.basePath);
    }

}

export class StatsApiApi extends RESTDataSource {
    constructor(baseUrl?: string) {
        super();
        this.baseURL = baseUrl;
    }
    paramCreator = StatsApiFetchParamCreator()
    statscurrent(pretty?: boolean, ): Promise<InlineResponse20019> {
        const args = this.paramCreator.statscurrent(pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
}


/**
 * StatsApi - fetch parameter creator
 * @export
 */
export const StatsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the most recent index statistics.  Example: https://api.podcastindex.org/api/1.0/stats/current?pretty
         * @summary Current
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statscurrent(pretty?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/stats/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return the most recent index statistics.  Example: https://api.podcastindex.org/api/1.0/stats/current?pretty
         * @summary Current
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statscurrent(pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20019> {
            const localVarFetchArgs = StatsApiFetchParamCreator(configuration).statscurrent(pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return the most recent index statistics.  Example: https://api.podcastindex.org/api/1.0/stats/current?pretty
         * @summary Current
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statscurrent(pretty?: boolean, options?: any) {
            return StatsApiFp(configuration).statscurrent(pretty, options)(fetch, basePath);
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * Return the most recent index statistics.  Example: https://api.podcastindex.org/api/1.0/stats/current?pretty
     * @summary Current
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statscurrent(pretty?: boolean, options?: any) {
        return StatsApiFp(this.configuration).statscurrent(pretty, options)(this.fetch, this.basePath);
    }

}

export class ValueApiApi extends RESTDataSource {
    constructor(baseUrl?: string) {
        super();
        this.baseURL = baseUrl;
    }
    paramCreator = ValueApiFetchParamCreator()
    valuebyfeedid(id: number, pretty?: boolean, ): Promise<InlineResponse20017> {
        const args = this.paramCreator.valuebyfeedid(id, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
    valuebyfeedurl(url: string, pretty?: boolean, ): Promise<InlineResponse20018> {
        const args = this.paramCreator.valuebyfeedurl(url, pretty, )

        // @ts-ignore
        return this.fetch(Object.assign(args.options, { path: args.url }))
    }
}


/**
 * ValueApi - fetch parameter creator
 * @export
 */
export const ValueApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This call returns the information for supporting the podcast via one of the \"Value for Value\" methods from the PodcastIndex ID.  Examples:    - https://api.podcastindex.org/api/1.0/value/byfeedid?id=920666&pretty   - https://api.podcastindex.org/api/1.0/value/byfeedid?id=779873&pretty
         * @summary By Feed ID
         * @param {number} id The PodcastIndex Feed ID to search for.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valuebyfeedid(id: number, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling valuebyfeedid.');
            }
            const localVarPath = `/value/byfeedid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call returns the information for supporting the podcast via one of the \"Value for Value\" methods from feed URL.  Examples:    - https://api.podcastindex.org/api/1.0/value/byfeedurl?url=https://mp3s.nashownotes.com/pc20rss.xml&pretty   - https://api.podcastindex.org/api/1.0/value/byfeedurl?url=https://lespoesiesdheloise.fr/@heloise/feed.xml&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valuebyfeedurl(url: string, pretty?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new RequiredError('url','Required parameter url was null or undefined when calling valuebyfeedurl.');
            }
            const localVarPath = `/value/byfeedurl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Key")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Date required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Auth-Date")
					: configuration.apiKey;
                localVarHeaderParameter["X-Auth-Date"] = localVarApiKeyValue;
            }

            // authentication User Agent required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("User-Agent")
					: configuration.apiKey;
                localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValueApi - functional programming interface
 * @export
 */
export const ValueApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This call returns the information for supporting the podcast via one of the \"Value for Value\" methods from the PodcastIndex ID.  Examples:    - https://api.podcastindex.org/api/1.0/value/byfeedid?id=920666&pretty   - https://api.podcastindex.org/api/1.0/value/byfeedid?id=779873&pretty
         * @summary By Feed ID
         * @param {number} id The PodcastIndex Feed ID to search for.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valuebyfeedid(id: number, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20017> {
            const localVarFetchArgs = ValueApiFetchParamCreator(configuration).valuebyfeedid(id, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call returns the information for supporting the podcast via one of the \"Value for Value\" methods from feed URL.  Examples:    - https://api.podcastindex.org/api/1.0/value/byfeedurl?url=https://mp3s.nashownotes.com/pc20rss.xml&pretty   - https://api.podcastindex.org/api/1.0/value/byfeedurl?url=https://lespoesiesdheloise.fr/@heloise/feed.xml&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valuebyfeedurl(url: string, pretty?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20018> {
            const localVarFetchArgs = ValueApiFetchParamCreator(configuration).valuebyfeedurl(url, pretty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ValueApi - factory interface
 * @export
 */
export const ValueApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This call returns the information for supporting the podcast via one of the \"Value for Value\" methods from the PodcastIndex ID.  Examples:    - https://api.podcastindex.org/api/1.0/value/byfeedid?id=920666&pretty   - https://api.podcastindex.org/api/1.0/value/byfeedid?id=779873&pretty
         * @summary By Feed ID
         * @param {number} id The PodcastIndex Feed ID to search for.
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valuebyfeedid(id: number, pretty?: boolean, options?: any) {
            return ValueApiFp(configuration).valuebyfeedid(id, pretty, options)(fetch, basePath);
        },
        /**
         * This call returns the information for supporting the podcast via one of the \"Value for Value\" methods from feed URL.  Examples:    - https://api.podcastindex.org/api/1.0/value/byfeedurl?url=https://mp3s.nashownotes.com/pc20rss.xml&pretty   - https://api.podcastindex.org/api/1.0/value/byfeedurl?url=https://lespoesiesdheloise.fr/@heloise/feed.xml&pretty
         * @summary By Feed URL
         * @param {string} url Podcast feed URL
         * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valuebyfeedurl(url: string, pretty?: boolean, options?: any) {
            return ValueApiFp(configuration).valuebyfeedurl(url, pretty, options)(fetch, basePath);
        },
    };
};

/**
 * ValueApi - object-oriented interface
 * @export
 * @class ValueApi
 * @extends {BaseAPI}
 */
export class ValueApi extends BaseAPI {
    /**
     * This call returns the information for supporting the podcast via one of the \"Value for Value\" methods from the PodcastIndex ID.  Examples:    - https://api.podcastindex.org/api/1.0/value/byfeedid?id=920666&pretty   - https://api.podcastindex.org/api/1.0/value/byfeedid?id=779873&pretty
     * @summary By Feed ID
     * @param {number} id The PodcastIndex Feed ID to search for.
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public valuebyfeedid(id: number, pretty?: boolean, options?: any) {
        return ValueApiFp(this.configuration).valuebyfeedid(id, pretty, options)(this.fetch, this.basePath);
    }

    /**
     * This call returns the information for supporting the podcast via one of the \"Value for Value\" methods from feed URL.  Examples:    - https://api.podcastindex.org/api/1.0/value/byfeedurl?url=https://mp3s.nashownotes.com/pc20rss.xml&pretty   - https://api.podcastindex.org/api/1.0/value/byfeedurl?url=https://lespoesiesdheloise.fr/@heloise/feed.xml&pretty
     * @summary By Feed URL
     * @param {string} url Podcast feed URL
     * @param {boolean} [pretty] If present, makes the output “pretty” to help with debugging.  Parameter shall not have a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public valuebyfeedurl(url: string, pretty?: boolean, options?: any) {
        return ValueApiFp(this.configuration).valuebyfeedurl(url, pretty, options)(this.fetch, this.basePath);
    }

}
